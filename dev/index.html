<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Air.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Air.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/noahbenson/Air.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Air.jl"><a class="docs-heading-anchor" href="#Air.jl">Air.jl</a><a id="Air.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Air.jl" title="Permalink"></a></h1><ul><li><a href="#Air.AbstractPArray"><code>Air.AbstractPArray</code></a></li><li><a href="#Air.AbstractPDict"><code>Air.AbstractPDict</code></a></li><li><a href="#Air.AbstractPSet"><code>Air.AbstractPSet</code></a></li><li><a href="#Air.AbstractPWDict"><code>Air.AbstractPWDict</code></a></li><li><a href="#Air.AbstractPWSet"><code>Air.AbstractPWSet</code></a></li><li><a href="#Air.AbstractSourceKernel"><code>Air.AbstractSourceKernel</code></a></li><li><a href="#Air.Actor"><code>Air.Actor</code></a></li><li><a href="#Air.ActorException"><code>Air.ActorException</code></a></li><li><a href="#Air.Delay"><code>Air.Delay</code></a></li><li><a href="#Air.FunctionSourceKernel"><code>Air.FunctionSourceKernel</code></a></li><li><a href="#Air.LazyDict"><code>Air.LazyDict</code></a></li><li><a href="#Air.LazyIdDict"><code>Air.LazyIdDict</code></a></li><li><a href="#Air.PArray"><code>Air.PArray</code></a></li><li><a href="#Air.PDict"><code>Air.PDict</code></a></li><li><a href="#Air.PHeap"><code>Air.PHeap</code></a></li><li><a href="#Air.PIdDict"><code>Air.PIdDict</code></a></li><li><a href="#Air.PIdLinearDict"><code>Air.PIdLinearDict</code></a></li><li><a href="#Air.PIdLinearSet"><code>Air.PIdLinearSet</code></a></li><li><a href="#Air.PIdSet"><code>Air.PIdSet</code></a></li><li><a href="#Air.PLinearDict"><code>Air.PLinearDict</code></a></li><li><a href="#Air.PLinearSet"><code>Air.PLinearSet</code></a></li><li><a href="#Air.PMatrix"><code>Air.PMatrix</code></a></li><li><a href="#Air.PSet"><code>Air.PSet</code></a></li><li><a href="#Air.PTree"><code>Air.PTree</code></a></li><li><a href="#Air.PVector"><code>Air.PVector</code></a></li><li><a href="#Air.PWDict"><code>Air.PWDict</code></a></li><li><a href="#Air.PWIdDict"><code>Air.PWIdDict</code></a></li><li><a href="#Air.PWIdSet"><code>Air.PWIdSet</code></a></li><li><a href="#Air.PWSet"><code>Air.PWSet</code></a></li><li><a href="#Air.Promise"><code>Air.Promise</code></a></li><li><a href="#Air.ReentrantRef"><code>Air.ReentrantRef</code></a></li><li><a href="#Air.Source"><code>Air.Source</code></a></li><li><a href="#Air.SourceAbortError"><code>Air.SourceAbortError</code></a></li><li><a href="#Air.SourceKernelError"><code>Air.SourceKernelError</code></a></li><li><a href="#Air.SourceReadError"><code>Air.SourceReadError</code></a></li><li><a href="#Air.Transaction"><code>Air.Transaction</code></a></li><li><a href="#Air.TransactionalRef"><code>Air.TransactionalRef</code></a></li><li><a href="#Air.Var"><code>Air.Var</code></a></li><li><a href="#Air.Volatile"><code>Air.Volatile</code></a></li><li><a href="#Air._ActorMsg"><code>Air._ActorMsg</code></a></li><li><a href="#Air._source_claim-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},UInt128,UInt128}} where K where T"><code>Air._source_claim</code></a></li><li><a href="#Air._source_ensure-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},UInt128,Union{Nothing, UInt128}}} where K where T"><code>Air._source_ensure</code></a></li><li><a href="#Air.current_tx-Tuple{}"><code>Air.current_tx</code></a></li><li><a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K"><code>Air.delete</code></a></li><li><a href="#Air.depth_to_bitshift-Tuple{Integer}"><code>Air.depth_to_bitshift</code></a></li><li><a href="#Air.equalfn-Tuple{T} where T"><code>Air.equalfn</code></a></li><li><a href="#Air.geterror-Union{Tuple{Source{T,K}}, Tuple{K}, Tuple{T}} where K where T"><code>Air.geterror</code></a></li><li><a href="#Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.geterror</code></a></li><li><a href="#Air.getfilter-Union{Tuple{Volatile{T}}, Tuple{T}} where T"><code>Air.getfilter</code></a></li><li><a href="#Air.getfinalize-Union{Tuple{Volatile{T}}, Tuple{T}} where T"><code>Air.getfinalize</code></a></li><li><a href="#Air.getpair"><code>Air.getpair</code></a></li><li><a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S}} where S where D where F where W where T"><code>Air.getweight</code></a></li><li><a href="#Air.hashfn-Tuple{T} where T"><code>Air.hashfn</code></a></li><li><a href="#Air.highmask-Union{Tuple{K}, Tuple{T}, Tuple{K,Type{T}}} where K&lt;:Integer where T&lt;:Unsigned"><code>Air.highmask</code></a></li><li><a href="#Air.insert"><code>Air.insert</code></a></li><li><a href="#Air.lockall"><code>Air.lockall</code></a></li><li><a href="#Air.lowmask-Union{Tuple{K}, Tuple{T}, Tuple{K,Type{T}}} where K&lt;:Integer where T&lt;:Unsigned"><code>Air.lowmask</code></a></li><li><a href="#Air.pop"><code>Air.pop</code></a></li><li><a href="#Air.popat"><code>Air.popat</code></a></li><li><a href="#Air.popfirst"><code>Air.popfirst</code></a></li><li><a href="#Air.ptree_bitshift-Tuple{UInt64}"><code>Air.ptree_bitshift</code></a></li><li><a href="#Air.ptree_cellindex-Tuple{UInt64,UInt64,UInt64}"><code>Air.ptree_cellindex</code></a></li><li><a href="#Air.ptree_cellindex!-Tuple{UInt64,UInt64,UInt64}"><code>Air.ptree_cellindex!</code></a></li><li><a href="#Air.ptree_cellkey-Tuple{UInt64,UInt64}"><code>Air.ptree_cellkey</code></a></li><li><a href="#Air.ptree_depth-Tuple{UInt64}"><code>Air.ptree_depth</code></a></li><li><a href="#Air.ptree_firstbit-Tuple{UInt64}"><code>Air.ptree_firstbit</code></a></li><li><a href="#Air.ptree_highbitdiff-Tuple{UInt64,UInt64}"><code>Air.ptree_highbitdiff</code></a></li><li><a href="#Air.ptree_id-Tuple{Integer,Integer}"><code>Air.ptree_id</code></a></li><li><a href="#Air.ptree_isbeneath-Tuple{UInt64,UInt64}"><code>Air.ptree_isbeneath</code></a></li><li><a href="#Air.ptree_maxleaf-Tuple{UInt64}"><code>Air.ptree_maxleaf</code></a></li><li><a href="#Air.ptree_minleaf-Tuple{UInt64}"><code>Air.ptree_minleaf</code></a></li><li><a href="#Air.ptree_minmaxleaf-Tuple{UInt64}"><code>Air.ptree_minmaxleaf</code></a></li><li><a href="#Air.ptree_parentid-Tuple{UInt64}"><code>Air.ptree_parentid</code></a></li><li><a href="#Air.ptree_shift-Tuple{UInt64}"><code>Air.ptree_shift</code></a></li><li><a href="#Air.push"><code>Air.push</code></a></li><li><a href="#Air.pushfirst"><code>Air.pushfirst</code></a></li><li><a href="#Air.receive-Union{Tuple{Source{T,K}}, Tuple{K}, Tuple{T}} where K where T"><code>Air.receive</code></a></li><li><a href="#Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T},S}} where S where T"><code>Air.reset</code></a></li><li><a href="#Air.reset-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},K}} where K where T"><code>Air.reset</code></a></li><li><a href="#Air.send-Tuple"><code>Air.send</code></a></li><li><a href="#Air.setfilter!-Union{Tuple{T}, Tuple{Volatile{T},Function}} where T"><code>Air.setfilter!</code></a></li><li><a href="#Air.setfinalize!-Union{Tuple{T}, Tuple{Volatile{T},Function}} where T"><code>Air.setfinalize!</code></a></li><li><a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S,X}} where X&lt;:Number where S where D where F where W where T"><code>Air.setweight</code></a></li><li><a href="#Air.take-Union{Tuple{Promise{T}}, Tuple{T}} where T"><code>Air.take</code></a></li><li><a href="#Air.tx-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function"><code>Air.tx</code></a></li><li><a href="#Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},S,Vararg{Any,N} where N}} where S where N where T"><code>Base.setindex</code></a></li><li><a href="#SparseArrays.dropzeros-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>SparseArrays.dropzeros</code></a></li><li><a href="#SparseArrays.findnz-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>SparseArrays.findnz</code></a></li><li><a href="#SparseArrays.nnz-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>SparseArrays.nnz</code></a></li><li><a href="#SparseArrays.nonzeros-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>SparseArrays.nonzeros</code></a></li><li><a href="#Air.@delay-Tuple{Expr}"><code>Air.@delay</code></a></li><li><a href="#Air.@memoize-Tuple{Expr}"><code>Air.@memoize</code></a></li><li><a href="#Air.@tx-Tuple{Any}"><code>Air.@tx</code></a></li><li><a href="#Air.@var-Tuple{Expr}"><code>Air.@var</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPArray" href="#Air.AbstractPArray"><code>Air.AbstractPArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPArray{T,N}</code></pre><p>The Abstract persistent array type represents any <code>Array</code>-like type that is persistent. The Air library provides the reified type <code>PArray{T,N}</code>.</p><p>See also: <a href="#Air.PArray"><code>PArray</code></a>, <a href="#Air.PVector"><code>PVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPDict" href="#Air.AbstractPDict"><code>Air.AbstractPDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPDict{K,V}</code></pre><p><code>AbstractPDict</code> is a subtype of <code>AbstractDict</code> that is extended only by persistent dictionary types such as <code>PDict</code> and <code>LazyDict</code>.</p><p>See also <a href="#Air.PDict"><code>PDict</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.LazyDict"><code>LazyDict</code></a>, <a href="#Air.PIdDict"><code>PIdDict</code></a>, <a href="#Air.LazyIdDict"><code>LazyIdDict</code></a>, <a href="#Air.PWIdDict"><code>PWIdDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL19-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPSet" href="#Air.AbstractPSet"><code>Air.AbstractPSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPSet{T}</code></pre><p><code>AbstractPSet</code> is an abstract type extended by persistent set types such as  <code>PSet</code> and `PWSet.</p><p>See also: <a href="#Air.PSet"><code>PSet</code></a>, <a href="#Air.PIdSet"><code>PIdSet</code></a>, <a href="#Air.PWSet"><code>PWSet</code></a>, <a href="#Air.PWIdSet"><code>PWIdSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPWDict" href="#Air.AbstractPWDict"><code>Air.AbstractPWDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPWDict</code></pre><p>AbstractPWDict is a subtype of AbstractPDict that is overloaded by classes that represent weighted persistent dictionaries.</p><p>See also: <a href="#Air.AbstractPDict"><code>AbstractPDict</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.AbstractPWSet"><code>AbstractPWSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pwdict.jl#LL15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPWSet" href="#Air.AbstractPWSet"><code>Air.AbstractPWSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPWSet{T,W}</code></pre><p>AbstractPWSet is an abstract type implemented by all persistent weighted set types.</p><p>See also: <a href="#Air.PWSet"><code>PWSet</code></a>, <a href="#Air.AbstractPSet"><code>AbstractPSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pwset.jl#LL15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractSourceKernel" href="#Air.AbstractSourceKernel"><code>Air.AbstractSourceKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbtractSourceKernel{T}</code></pre><p>An AbstractSourceKernel is an object that can be sampled to produce the next sample for a source. Objects of types descending from AbstractSourceKernel are not responsible for maintaining the multi-threaaded state exchange implied by sources; rather the represent a function that will be called discretely when samples are needed.</p><p>Source kernels use the pop! function to get values. Once popped, values cannot be reobtained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL400-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Actor" href="#Air.Actor"><code>Air.Actor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Actor{T}</code></pre><p>An actor is an object that represents an worker-thread to which tasks can be scheduled. Any scheduled function is guaranteed to be evaluated at some point in the future in some other thread, and the return value of that function will become the new value held by the actor. Each function, when it is run, is passed the actor&#39;s value as one of its argument.</p><p>Like with Refs, you can access an actor&#39;s current value using <code>actor[]</code>. Within a transaction, this will be guaranteed to remain fixed for the duration of the transaction; outside of a transaction, this may change at arbitrary times.</p><p>Actors may be initialized with post-processing functions. These functions are called immediately after executing any scheduled function and are given as their first argument the original agent value and as their second argument the return value of the scheduled function. Instead of saving this return value, the return value of the post-processing function is saved in the agent. This is useful for agents whose job is, for example, to serialize output to a log file being written to across many threads. If we run something like  <code>send(log_agent, println, &quot;Some log message&quot;)</code> the <code>println</code> function will return nothing, which we would like to convert back into the log file so that subsequent <code>send</code> calls can continue to use the <code>println</code> fuction.</p><p>Actors may additionally be given an error handler. Whenever an exception occurs during a scheduled function, the error handler will be called with the arguments of (1) the agent object, (2) the current agent value, and (3) the exception that was caught. When an error has occurred, any attempt to schedule a function to the agent or to read from the agent will cause an exception to be raised. The error may be examined using <code>actorerror(actor)</code> and restarted using <code>restart(actor)</code>.</p><p>All fields in an agent object should be considered strictly private. These fields are likely to change between releases, and changing the values will break your code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL175-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ActorException" href="#Air.ActorException"><code>Air.ActorException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ActorException{T}(error, value, argno, args)</code></pre><p>An ActorException object is thrown whenever one attempts to obtain the value of or send a function to an actor that is in an error state. An error state occurs when an unhandled exception is raised while an actor is processing a sent function. In such a case the <code>actorerror()</code> and <code>restart()</code> functions may be used. The <code>actorerror()</code> function yields an ActorException object in which the exception that was raised is stored as <code>error</code>, the value of the actor when the send was run is stored in <code>value</code>, and the <code>args</code> and <code>argno</code> give the full contex of the send (i.e., the fucntion followed by the arguments in <code>args</code> and the argument number that corresponds to the actor in <code>argno</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL142-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Delay" href="#Air.Delay"><code>Air.Delay</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Delay{T}</code></pre><p><code>Delay</code> objects can be used to lazily calculate a single value the first time it is requested. They act like <code>Ref</code>s in that you access a delay <code>d</code> via <code>d[]</code>. <code>Delay</code> objects are thread-safe and are functionally immutable.</p><p>See also: <a href="#Air.@delay-Tuple{Expr}"><code>@delay</code></a>, <a href="#Air.LazyDict"><code>LazyDict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; # Create a Delay with a long run time.
       d = Delay{Int64}(() -&gt; (println(&quot;Running.&quot;); sleep(2); 10))
Delay{Int64}(&lt;...&gt;)

julia&gt; # Start a few threads, each of which attempt to read it. The function
       # will only run once.
       for th in [(Threads.@spawn d[]) for _ in 1:5]; wait(th) end
Running.

julia&gt; # Ensure that it produced the correct value and doesn&#39;t run again.
       d[]
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/util.jl#LL17-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.FunctionSourceKernel" href="#Air.FunctionSourceKernel"><code>Air.FunctionSourceKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FunctionSourceKernel{T}</code></pre><p>A FunctionSourceKernel{T} object holds a function that is called every time a new source sample is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL416-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.LazyDict" href="#Air.LazyDict"><code>Air.LazyDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyDict{K,V}</code></pre><p>A dictionay type equivalent to <code>PDict{K,V}</code> in every way except that for any value in the dict that is a <code>Delay</code> object, the dictionary hides the delay and always returns the delay&#39;s value. This allows any value that has not yet been requested to be lazily unevaluated.</p><p>See also: <a href="#Air.PDict"><code>PDict</code></a>, <code>Base.Dict</code>, <a href="#Air.LazyIdDict"><code>LazyIdDict</code></a>, <a href="#Air.Delay"><code>Delay</code></a>, <a href="#Air.@delay-Tuple{Expr}"><code>@delay</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; LazyDict()
LazyDict{Any,Any}()</code></pre><pre><code class="language-julia-repl">julia&gt; LazyDict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
LazyDict{Symbol,Real} with 3 entries:
  :c =&gt; 12.8
  :a =&gt; 1
  :b =&gt; 2</code></pre><pre><code class="language-julia-repl">julia&gt; d = LazyDict{Symbol,Float64}(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
LazyDict{Symbol,Float64} with 3 entries:
  :c =&gt; 12.8
  :a =&gt; 1.0
  :b =&gt; 2.0

julia&gt; d2 = push(d, :d =&gt; Delay{Real}(() -&gt; (println(&quot;Running...&quot;); 0.5))); haskey(d2, :d)
true

julia&gt; d2[:d]
Running...
0.5

julia&gt; d2[:d]
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/lazydict.jl#LL158-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.LazyIdDict" href="#Air.LazyIdDict"><code>Air.LazyIdDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyIdDict{K,V}</code></pre><p>A dictionay type equivalent to <code>PIdDict{K,V}</code> in every way except that for any value in the dict that is a <code>Delay</code> object, the dictionary hides the delay and always returns the delay&#39;s value. This allows any value that has not yet been requested to be lazily unevaluated.</p><p>See also: <a href="#Air.PIdDict"><code>PIdDict</code></a>, <code>Base.IdDict</code>, <a href="#Air.LazyDict"><code>LazyDict</code></a>, <a href="#Air.Delay"><code>Delay</code></a>, <a href="#Air.@delay-Tuple{Expr}"><code>@delay</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; LazyIdDict()
LazyIdDict{Any,Any}()</code></pre><pre><code class="language-julia-repl">julia&gt; LazyIdDict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
LazyIdDict{Symbol,Real} with 3 entries:
  :b =&gt; 2
  :a =&gt; 1
  :c =&gt; 12.8</code></pre><p>```jldoctest; filter=r&quot;LazyIdDict{Symbol, ?Float64} with 3 entries:&quot; julia&gt; d = LazyIdDict{Symbol,Float64}(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8) LazyIdDict{Symbol,Float64} with 3 entries:   :c =&gt; 12.8   :a =&gt; 1.0   :b =&gt; 2.0</p><p>julia&gt; d2 = push(d, :d =&gt; Delay{Real}(() -&gt; (println(&quot;Running...&quot;); 0.5))); haskey(d2, :d) true</p><p>julia&gt; d2[:d] Running... 0.5</p><p>julia&gt; d2[:d] 0.5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/lazydict.jl#LL208-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PArray" href="#Air.PArray"><code>Air.PArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PArray{T,N}</code></pre><p>The PArray type is a persistent/immutable corrolary to the Array{T,N} type. Like Array, PArray can store n-dimensional non-ragged arrays. However, unlike Arrays, PArrays can create duplicates of themselves with finite edits in log-time.</p><p>PArrays have a similar interface as Arrays, but instead of the functions <code>push!</code>, <code>pop!</code>, and <code>setindex!</code>, PArrays use <code>push</code>, <code>pop</code>, and <code>setindex</code>. PArrays also have efficient implementations of <code>pushfirst</code> and <code>popfirst</code>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PArray()
0-element PArray{Any,1}</code></pre><pre><code class="language-julia-repl">julia&gt; u = PArray{Int,1}([1,2])
2-element PArray{Int64,1}:
 1
 2

julia&gt; push(u, 3)
3-element PArray{Int64,1}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/parray.jl#LL32-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PDict" href="#Air.PDict"><code>Air.PDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PDict{K,V}</code></pre><p>A dictionay type roughly equivalent to <code>Dict{K,V}</code> but that stores data using a persistent hash array mapped trie system that allows for efficient persistent operations. These operations are represented by non-mutating versions of the standard dictionary functions, such as <code>setindex</code> in place of <code>setindex!</code>, <code>push</code> in place of <code>push!</code>, and <code>pop</code> in place of <code>pop!</code>. These operations are performed in <code>O(log n)</code> time, and minimal data duplication is performed in  update operations.</p><p>See also: <a href="#Air.PIdDict"><code>PIdDict</code></a>, <code>Dict</code>, <a href="#Air.push"><code>push</code></a>, <a href="#Air.pop"><code>pop</code></a>, <a href="#Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},S,Vararg{Any,N} where N}} where S where N where T"><code>setindex</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K"><code>delete</code></a>, <a href="#Air.insert"><code>insert</code></a>, <a href="#Air.getpair"><code>getpair</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PDict()
PDict{Any,Any}()</code></pre><pre><code class="language-julia-repl">julia&gt; PDict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
PDict{Symbol,Real} with 3 entries:
  :c =&gt; 12.8
  :a =&gt; 1
  :b =&gt; 2</code></pre><pre><code class="language-julia-repl">julia&gt; d = PDict{Symbol,Float64}(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
PDict{Symbol,Float64} with 3 entries:
  :c =&gt; 12.8
  :a =&gt; 1.0
  :b =&gt; 2.0

julia&gt; :b in keys(d)
true

julia&gt; d[:c]
12.8

julia&gt; push(d, :d =&gt; 0.1)
PDict{Symbol,Float64} with 4 entries:
  :d =&gt; 0.1
  :c =&gt; 12.8
  :a =&gt; 1.0
  :b =&gt; 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pdict.jl#LL318-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PHeap" href="#Air.PHeap"><code>Air.PHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PHeap{T,W,F}</code></pre><p>A <code>PHeap</code> object is a priority queue to which objects can be <code>push</code>ed and given a particular weight. <code>PHeap</code>s can then be <code>iterate</code>d in weighted order, <code>pop</code>ped in weighted order, and the <code>first</code>  element may be obtained in weighted order. Additionally, a random sample may be drawn from a heap, which uses the distribution implied by the relative weights of the items in the heap.</p><p><code>PHeap</code> objects may be initialized with a single argument of type <code>F &lt;: Function</code>, in which case this function is used to compare the weights for ordering. By default this is <code>&gt;</code> such that high weights are retrieved first by the <code>first()</code> function and removed first by the <code>pop()</code> function. Note, however, that the relative weights are still used by the <code>rand</code> function regardless of the ordering function, so negative values cannot be used.</p><p>See also: <a href="#Air.PWSet"><code>PWSet</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.pop"><code>pop</code></a>, <code>Base.first</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pheap.jl#LL16-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PIdDict" href="#Air.PIdDict"><code>Air.PIdDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PIdDict{K,V}</code></pre><p>A dictionay type roughly equivalent to <code>IdDict{K,V}</code> but that stores data using a persistent hash array mapped trie system that allows for efficient persistent operations. These operations are represented by non-mutating versions of the standard dictionary functions, such as <code>setindex</code> in place of <code>setindex!</code>, <code>push</code> in place of <code>push!</code>, and <code>pop</code> in place of <code>pop!</code>. These operations are performed in <code>O(log n)</code> time, and minimal data duplication is performed in  update operations.</p><p>See also: <a href="#Air.PDict"><code>PDict</code></a>, <code>Base.IdDict</code>, <a href="#Air.push"><code>push</code></a>, <a href="#Air.pop"><code>pop</code></a>, <a href="#Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},S,Vararg{Any,N} where N}} where S where N where T"><code>setindex</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K"><code>delete</code></a>, <a href="#Air.insert"><code>insert</code></a>, <a href="#Air.getpair"><code>getpair</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PIdDict()
PIdDict{Any,Any}()
</code></pre><p>jldoctest; filter=r&quot;PIdDict{Symbol, ?Real} with 3 entries:&quot; julia&gt; PIdDict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8) PIdDict{Symbol,Real} with 3 entries:   :c =&gt; 12.8   :a =&gt; 1   :b =&gt; 2</p><pre><code class="language-none"></code></pre><p>jldoctest; filter=r&quot;PIdDict{Symbol, ?Float64} with [34] entries:&quot; julia&gt; d = PIdDict{Symbol,Float64}(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8) PIdDict{Symbol,Float64} with 3 entries:   :c =&gt; 12.8   :a =&gt; 1.0   :b =&gt; 2.0</p><p>julia&gt; :b in keys(d) true</p><p>julia&gt; d[:c] 12.8</p><p>julia&gt; push(d, :d =&gt; 0.1) PIdDict{Symbol,Float64} with 4 entries:   :d =&gt; 0.1   :c =&gt; 12.8   :a =&gt; 1.0   :b =&gt; 2.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pdict.jl#LL374-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PIdLinearDict" href="#Air.PIdLinearDict"><code>Air.PIdLinearDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PIdLinearDict{K,V}</code></pre><p>An identity-based persistent dict type that uses a simple array representation internally; accordingly <code>PIdLinearDict</code> does not peform persistent operations such as <code>setindex</code>, <code>push</code>, and <code>delete</code> efficiently. It is intended to be used by Air internally as a sub-dict that stores items whose hash values are identical.</p><p>See also: <a href="#Air.PLinearDict"><code>PLinearDict</code></a>, <a href="#Air.PIdDict"><code>PIdDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pdict.jl#LL181-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PIdLinearSet" href="#Air.PIdLinearSet"><code>Air.PIdLinearSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PIdLinearSet{T}</code></pre><p>A persistent <code>IdSet</code> type that uses a simple array representation internally; accordingly <code>PIdLinearSet</code> does not peform persistent operations such as <code>setindex</code>, <code>push</code>, and <code>delete</code> efficiently. It is intended to be used by Air internally as a set that stores items whose hash values are identical.</p><p>See also: <a href="#Air.PLinearSet"><code>PLinearSet</code></a>, <a href="#Air.PSet"><code>PSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pset.jl#LL160-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PIdSet" href="#Air.PIdSet"><code>Air.PIdSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PIdSet{T}</code></pre><p>A persistent identity-based set type that uses an array hash-mapped trie structure to allow for efficient updating of the set using the persistent operations defined by Air such as <code>push</code>, and <code>delete</code>.</p><p>See also: <code>Set</code>, <a href="#Air.PIdSet"><code>PIdSet</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PIdSet()
PIdSet{Any}()

julia&gt; :a in PIdSet([:a, :b, :c])
true

julia&gt; :d in PIdSet([:a, :b, :c])
false

julia&gt; :d in push(PIdSet(), :d)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pset.jl#LL301-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PLinearDict" href="#Air.PLinearDict"><code>Air.PLinearDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLinearDict{K,V}</code></pre><p>A persistent dict type that uses a simple array representation internally; accordingly <code>PLinearDict</code> does not peform persistent operations such as <code>setindex</code>, <code>push</code>, and <code>delete</code> efficiently. It is intended to be used by Air internally as a sub-dict that stores items whose hash values are identical.</p><p>See also: <a href="#Air.PIdLinearDict"><code>PIdLinearDict</code></a>, <a href="#Air.PDict"><code>PDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pdict.jl#LL171-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PLinearSet" href="#Air.PLinearSet"><code>Air.PLinearSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLinearSet{T}</code></pre><p>A persistent set type that uses a simple array representation internally; accordingly <code>PLinearSet</code> does not peform persistent operations such as <code>setindex</code>, <code>push</code>, and <code>delete</code> efficiently. It is intended to be used by Air internally as a set that stores items whose hash values are identical.</p><p>See also: <a href="#Air.PIdLinearSet"><code>PIdLinearSet</code></a>, <a href="#Air.PSet"><code>PSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pset.jl#LL149-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PMatrix" href="#Air.PMatrix"><code>Air.PMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PMatrix{T}</code></pre><p>An alias for <code>PArray{T,2}</code>, representing a persistent matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/parray.jl#LL131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PSet" href="#Air.PSet"><code>Air.PSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSet{T}</code></pre><p>A persistent set type that uses an array hash-mapped trie structure to allow for efficient updating of the set using the persistent operations defined by Air such as <code>setindex</code>, <code>push</code>, and <code>delete</code>.</p><p>See also: <code>Set</code>, <a href="#Air.PIdSet"><code>PIdSet</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PSet()
PSet{Any}()

julia&gt; :a in PSet([:a, :b, :c])
true

julia&gt; :d in PSet([:a, :b, :c])
false

julia&gt; :d in push(PSet(), :d)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pset.jl#LL270-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PTree" href="#Air.PTree"><code>Air.PTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PTree{T}</code></pre><p>PTree is a persistent tree/array hybrid that maps arbitrary unsigned integers (type HASH_T) to values. It can efficiently be used for arrays or for hash-maps, and supports efficient lookup, association, and dissociation.</p><p>All fields of a PTree should be considered strictly private, as modification of the fields may result in a kernel crash. The properties of a PTree are both immutable and safe to inpect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL210-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PVector" href="#Air.PVector"><code>Air.PVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PVector{T}</code></pre><p>An alias for <code>PArray{T,1}</code>, representing a persistent vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/parray.jl#LL118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PWDict" href="#Air.PWDict"><code>Air.PWDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PWDict{K,V}</code></pre><p>A persistent dictionary with weighted pairs. As such, a <code>PWDict</code> supports the typical operations of a <code>PDict</code> as well as the following:</p><ul><li>The <code>first</code> function yields the key-value pair with the highest weight.</li><li>The <code>pop</code> function yields a copy of the dictionary without the pair that has the highest weight.</li><li>Iteration occurs in the order of greatest to least weight.</li><li>The weights can be changed with the <code>getweight</code> and <code>setweight</code> functions; <code>setweight</code> yields a duplicate dictionary with updated weights.</li></ul><p>See also: <a href="#Air.PDict"><code>PDict</code></a>, <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S}} where S where D where F where W where T"><code>getweight</code></a>, <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S,X}} where X&lt;:Number where S where D where F where W where T"><code>setweight</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PWDict{Symbol,Int}(:a =&gt; (1,0.1), :b =&gt; (2, 0.2), :c =&gt; (3, 0.3))
PWDict{Symbol,Int64,Float64} with 3 entries:
  :c =&gt; 3
  :b =&gt; 2
  :a =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pwdict.jl#LL183-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PWIdDict" href="#Air.PWIdDict"><code>Air.PWIdDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PWIdDict{K,V}</code></pre><p>A persistent dictionary with weighted pairs. As such, a <code>PWIdDict</code> supports the typical operations of a <code>PIdDict</code> as well as the following:</p><ul><li>The <code>first</code> function yields the key-value pair with the highest weight.</li><li>The <code>pop</code> function yields a copy of the dictionary without the pair that has the highest weight.</li><li>Iteration occurs in the order of greatest to least weight.</li><li>The weights can be changed with the <code>getweight</code> and <code>setweight</code> functions; <code>setweight</code> yields a duplicate dictionary with updated weights.</li></ul><p>See also: <a href="#Air.PIdDict"><code>PIdDict</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S}} where S where D where F where W where T"><code>getweight</code></a>, <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S,X}} where X&lt;:Number where S where D where F where W where T"><code>setweight</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PWIdDict{Symbol,Int}(:a =&gt; (1,0.1), :b =&gt; (2, 0.2), :c =&gt; (3, 0.3))
PWIdDict{Symbol,Int64,Float64} with 3 entries:
  :c =&gt; 3
  :b =&gt; 2
  :a =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pwdict.jl#LL213-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PWIdSet" href="#Air.PWIdSet"><code>Air.PWIdSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PWIdSet{T}</code></pre><p>A persistent set with weighted elements. As such, a <code>PWIdSet</code> supports the typical operations of a <code>PIdSet</code> as well as the following:</p><ul><li>The <code>first</code> function yields the element with the highest weight.</li><li>The <code>pop</code> function yields a copy of the set without the element that has the highest weight.</li><li>Iteration occurs in the order of greatest to least weight.</li><li>The weights can be changed with the <code>getweight</code> and <code>setweight</code> functions; <code>setweight</code> yields a duplicate dictionary with updated weights.</li></ul><p>See also: <a href="#Air.PIdSet"><code>PIdSet</code></a>, <a href="#Air.PWSet"><code>PWSet</code></a>, <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S}} where S where D where F where W where T"><code>getweight</code></a>, <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S,X}} where X&lt;:Number where S where D where F where W where T"><code>setweight</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PWIdSet{Symbol}(:a =&gt; 0.1, :b =&gt; 0.2, :c =&gt; 0.3)
PWIdSet{Symbol,Float64} with 3 elements:
  :c
  :b
  :a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pwset.jl#LL159-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PWSet" href="#Air.PWSet"><code>Air.PWSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PWSet{K,V}</code></pre><p>A persistent set with weighted elements. As such, a <code>PWSet</code> supports the typical operations of a <code>PSet</code> as well as the following:</p><ul><li>The <code>first</code> function yields the element with the highest weight.</li><li>The <code>pop</code> function yields a copy of the set without the element that has the highest weight.</li><li>Iteration occurs in the order of greatest to least weight.</li><li>The weights can be changed with the <code>getweight</code> and <code>setweight</code> functions; <code>setweight</code> yields a duplicate dictionary with updated weights.</li></ul><p>See also: <a href="#Air.PSet"><code>PSet</code></a>, <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S}} where S where D where F where W where T"><code>getweight</code></a>, <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S,X}} where X&lt;:Number where S where D where F where W where T"><code>setweight</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PWSet{Symbol}(:a =&gt; 0.1, :b =&gt; 0.2, :c =&gt; 0.3)
PWSet{Symbol,Float64} with 3 elements:
  :c
  :b
  :a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pwset.jl#LL129-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Promise" href="#Air.Promise"><code>Air.Promise</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Promise{T}</code></pre><p>Promise objects represent placeholders for values that may or may not have been delivered yet. This is effectively a <code>Channel</code> object that can only be <code>put!</code> to a single time and all <code>take</code> calls on the promise will return that value. Promise values can be accessed via the <code>take()</code> function (not the <code>take!()</code> function) or via <code>p[]</code> for promise <code>p</code>. In both cases, the running thread is suspended until a value is delivered.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; p = Promise{Symbol}()
Promise{Symbol}(&lt;...&gt;)

julia&gt; isready(p)
false

julia&gt; put!(p, :value)
:value

julia&gt; isready(p)
true

julia&gt; take(p)
:value

julia&gt; p[]
:value</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/util.jl#LL327-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ReentrantRef" href="#Air.ReentrantRef"><code>Air.ReentrantRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReentrantRef{T}</code></pre><p>A ReentrantRef is a type of ref object that is thread-safe. There are a few strategies for this, each of which are encoded in a different object type that inheits from ReentrantRef. These types are as follows.</p><p>Var: Var objects act like Ref objects except that changes to them are exclusively task-local.</p><p>Actor: Actor objects obey the actor pattern; you can send(fn, actor, args...) where fn is a function that is, in another thread at some point, called as fn(actor[], args...). The new value of the actor after running fn is the return value of the call.</p><p>Volatile: Volatile objects are refs that can be changed by any thread but that must be changed only within a synchronized transaction that ensures that all reads and writes of volatiles, as well as reads fom and sends to actors, are atomic: either they all happen successfully, or none of them do.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL9-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Source" href="#Air.Source"><code>Air.Source</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Source{T,K}</code></pre><p>Source objects work with transactions such that any samples taken from a source during a transaction either entirely occur or do not occur. I.e., if a transaction is rolled back or if an exception occurs during a transaction after a sampling from a source, then the sampling is rolled back.</p><p>Sources object their samples from Source kernel objects. The type parameter K must be the kernel type while T is the type parameter of type K (i.e., K is something like FunctionalSourceKernel{T}).</p><p>Sources can be sampled via the get() function. Althrough get() can be called either inside or outside of a transaction, when called inside of a transaction, the get is only performed when the transaction succeeds. Sources are thus safe to read from in transactions, unlike files and input streams.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL427-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.SourceAbortError" href="#Air.SourceAbortError"><code>Air.SourceAbortError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SourceAbortError{T,K}</code></pre><p>A SourceAbortError is raised when a task is reading from a source (i.e., waiting for a source-kernel to pop a value) and a reset is issued to the source. In general this shouldn&#39;t happen because errors should only arise from the task waiting on the kernel itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL483-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.SourceKernelError" href="#Air.SourceKernelError"><code>Air.SourceKernelError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SourceKernelError{T,K}</code></pre><p>A SourceKernelError is raised when an operation is attempted on a source whose kernel has raised an exception. The error of a source s may also be extracted via geterror(s).</p><p>For a SourceKernelError object err, err.source is the original source, err.task is the task that was attempting to read the actor when the error was caught, and err.error is the thrown object itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL494-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.SourceReadError" href="#Air.SourceReadError"><code>Air.SourceReadError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SourceReadError{T,K}</code></pre><p>Source read errors are generated when, during a transaction, is being read by multiple threads at once and becomes invalid for the current trasnaction. This is not really an error, and users should not encounter these exceptios; rather they should result in transaction retries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL470-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Transaction" href="#Air.Transaction"><code>Air.Transaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Transaction</code></pre><p>A transaction object keeps track of what is going on during a particular transaction. These are generally low-level objects that shouldn&#39;t be touched directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL548-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.TransactionalRef" href="#Air.TransactionalRef"><code>Air.TransactionalRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TransactionalRef{T}</code></pre><p>A TransactionalRef is a reentrant ref that additional participates in transactions. Transactional refs include Actors and Volatiles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Var" href="#Air.Var"><code>Air.Var</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Var{T}</code></pre><p>A Var object represents a task-local piece of data with a default value. You can access a var with <code>var[]</code> and you can set it with <code>var[] = newval</code>. However, the new assignment will always be task-local only. Because of this, Vars are safe to access and update in a multi-threaded program.</p><p>All fields of a Var should be considered strictly private.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL43-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Volatile" href="#Air.Volatile"><code>Air.Volatile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Volatile{T}(value)
Volatile{T}(value, filter_fn)
volatile{T}(value, filter_fn, finalize_fn)</code></pre><p>Volatile objects are Ref objects that must be used in conjunction with transaction blocks (see <code>Air.@tx</code>). The value of a Volatile can be accessed at any time, and there is no particular guarantee that a Volatile&#39;s value won&#39;t be changed by another thread outside of a transaction. Volatile objects can only be set inside of a transaction, however, and within a transaction, a Volatile&#39;s value is guaranteed to be constant.</p><p>The arguments filter<em>fn and finnalize</em>fn are functions for making sure that the value of a volatile conforms to some standard. The two functions are similar, but are intended for slightly different use cases:</p><ul><li>filter<em>fn is called every time the value of a volatile is set. The value saved in the volatile is filter</em>fn(value) instead of value itself.</li><li>finnalize<em>fn is called with the volatile&#39;s value immediately after the body of the transaction has completed, but before a commit is attempted. The finalize</em>fnn function acts like the filter<em>fn in that check</em>fn(value) replaces the value in the volatile.</li></ul><p>Both filter<em>fn and finalize</em>fn can throw exceptions to abort the transaction.</p><p>For a volatile <code>v</code>, one may set <code>v</code>&#39;s stored value via <code>v[] = value</code>. This must be done inside a transaction (via <code>tx</code> or <code>@tx</code>). To change the filter or the finalize functions, use the <code>setfilter!</code> and <code>setfinalize!</code> functions, both of which also must be run in transactions as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL347-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air._ActorMsg" href="#Air._ActorMsg"><code>Air._ActorMsg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">_ActorMsg{T}</code></pre><p>The (private) type of a message that is queued for an actor to eventually run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air._source_claim-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},UInt128,UInt128}} where K where T" href="#Air._source_claim-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},UInt128,UInt128}} where K where T"><code>Air._source_claim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_source_claim(s, start_pos, n)</code></pre><p>Claims the first n elements after the given source position start<em>post from the source s and updates the source object buffer to be free of those elements and the source position to be position + n. If the source position has been updated from start</em>pos, a SourceReadError exception is thrown.</p><p>If n values have not already been ensured, then it is an error to call this function (i.e., it does not ensure the values, it just checks that the given start_pos is still equal to the source position).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL518-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air._source_ensure-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},UInt128,Union{Nothing, UInt128}}} where K where T" href="#Air._source_ensure-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},UInt128,Union{Nothing, UInt128}}} where K where T"><code>Air._source_ensure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_source_ensure(s, n)</code></pre><p>Ensures that the source s contains at least n items in its queue then yields a tuple (position, first<em>n) where position is the current stream position and first</em>n is the vector of the first n stream elements.</p><p>The condition for source s must not be locked when this is called.</p><p>If the start position moves out from underneath the source as it is waiting on the kernel, then a SourceReadError is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL1096-L1107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.current_tx-Tuple{}" href="#Air.current_tx-Tuple{}"><code>Air.current_tx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">current_tx()</code></pre><p>Yields the current transaction, or nothing if there is no transaction running.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL571-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K" href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K"><code>Air.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete(coll, k)</code></pre><p>Yields a copy of the collection <code>coll</code> with the item associated with the given index or key <code>k</code> deleted. This function works on dictionaries, vectors, tuples, and sets, and it always yields a copy of the collection without modifying its aguments. For the persistent collections defined in Air, this is efficient, but for most mutable objects, this is <code>O(n)</code>.</p><p>See also: <code>Base.delete!</code>, <a href="#Air.insert"><code>insert</code></a>, <a href="#Air.pop"><code>pop</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; delete((:a,:b,:c,:d), 2)
(:a, :c, :d)</code></pre><pre><code class="language-julia-repl">julia&gt; u = [:a,:b,:c,:d]; delete(u, 1)
3-element Array{Symbol,1}:
 :b
 :c
 :d</code></pre><pre><code class="language-julia-repl">julia&gt; s1 = Set([:a,:b,:c,:d]); s2 = delete(s1, :d); (:d in s1, :d in s2)
(true, false)</code></pre><pre><code class="language-julia-repl">julia&gt; b = BitArray([0,0,0,1,0]); delete(b, 4)
4-element BitArray{1}:
 0
 0
 0
 0

julia&gt; b[2]
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL648-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.depth_to_bitshift-Tuple{Integer}" href="#Air.depth_to_bitshift-Tuple{Integer}"><code>Air.depth_to_bitshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">depth_to_bitshift(depth)</code></pre><p>Yields the tuple (B0,S) of the first bit index and the shift for the given depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.equalfn-Tuple{T} where T" href="#Air.equalfn-Tuple{T} where T"><code>Air.equalfn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">equalfn(x)</code></pre><p>If <code>x</code> is an object (such as a <code>PSet</code> or <code>Dict</code>) that has an opinion about equality, <code>equalfn(x)</code> returns the function that it uses.</p><p>See also: <a href="#Air.hashfn-Tuple{T} where T"><code>hashfn</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; equalfn(Dict) == isequal
true

julia&gt; equalfn(IdDict) == (===)
true

julia&gt; equalfn(PSet) == isequal
true

julia&gt; equalfn(PArray)
ERROR: ArgumentError: no equalfn for type PArray</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL50-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T" href="#Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.geterror</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getrerror(actor)</code></pre><p>If the given actor object is currently in an error state, then yields the ActorException object that describes the error. Otherwise, yields nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL971-L976">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.geterror-Union{Tuple{Source{T,K}}, Tuple{K}, Tuple{T}} where K where T" href="#Air.geterror-Union{Tuple{Source{T,K}}, Tuple{K}, Tuple{T}} where K where T"><code>Air.geterror</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geterror(s)</code></pre><p>Yields the error raised by the source-kernel for the source object s if s is in an error-state; otherwise yields nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL995-L1000">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.getfilter-Union{Tuple{Volatile{T}}, Tuple{T}} where T" href="#Air.getfilter-Union{Tuple{Volatile{T}}, Tuple{T}} where T"><code>Air.getfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getfilter(v)</code></pre><p>Yields the filter-function for the volatile v.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL809-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.getfinalize-Union{Tuple{Volatile{T}}, Tuple{T}} where T" href="#Air.getfinalize-Union{Tuple{Volatile{T}}, Tuple{T}} where T"><code>Air.getfinalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getfinalize(v)</code></pre><p>Yields the finalize-function for the volatile v.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL815-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.getpair" href="#Air.getpair"><code>Air.getpair</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getpair(d, k)</code></pre><p>If the key <code>k</code> is found in the dictionary <code>d</code>, yields the pair (<code>k =&gt; d[k]</code>); otherwise yields <code>missing</code>.</p><p>See also: <code>Base.get</code>, <code>Base.getindex</code>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 3); getpair(d, :a)
:a =&gt; 1

julia&gt; getpair(d, :x)
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL798-L821">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S}} where S where D where F where W where T" href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S}} where S where D where F where W where T"><code>Air.getweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getweight(h, x)</code></pre><p>Yields the weight for the given value x in the given persistent heap or persistent weighted collection h. If h is a weighted dictionary, then x should be the key.</p><p>If the key or object x is not found in the collection h, then 0 is returned.</p><p>See also: <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S,X}} where X&lt;:Number where S where D where F where W where T"><code>setweight</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.PWSet"><code>PWSet</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; d = PWSet{Symbol}(:a =&gt; 1.0, :b =&gt; 2.0, :c =&gt; 3.0)
PWSet{Symbol,Float64} with 3 elements:
  :c
  :b
  :a

julia&gt; getweight(d, :a)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pheap.jl#LL229-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.hashfn-Tuple{T} where T" href="#Air.hashfn-Tuple{T} where T"><code>Air.hashfn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hashfn(x)</code></pre><p>If <code>x</code> is an object (such as a <code>PSet</code> or <code>Dict</code>) that has an opinion about how it hashes objects, <code>hashfn(x)</code> returns the function that it uses. It is sufficient in almost all circumstances to define <code>equalfn(T)</code>; the <code>hashfn</code> should always match the <code>equalfn</code> regardless.</p><p>See also: <a href="#Air.equalfn-Tuple{T} where T"><code>equalfn</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; hashfn(Dict) == hash
true

julia&gt; hashfn(IdDict) == objectid
true

julia&gt; hashfn(PSet) == hash
true

julia&gt; hashfn(PArray)
ERROR: ArgumentError: no equalfn for type PArray</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL90-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.highmask-Union{Tuple{K}, Tuple{T}, Tuple{K,Type{T}}} where K&lt;:Integer where T&lt;:Unsigned" href="#Air.highmask-Union{Tuple{K}, Tuple{T}, Tuple{K,Type{T}}} where K&lt;:Integer where T&lt;:Unsigned"><code>Air.highmask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">highmask(bitno, T)
highmask(bitno)</code></pre><p>Yields a mask of (unsigned integer) type T with all bits above the given bit number set to true and all bits below that number set to false. The bit itself is set to true. Bits are indexed starting at 0.</p><p>The default value of T is the PTree hash type (HASH_T).</p><p>highmask(bitno) is equal to ~lowmask(bitno).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL76-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.insert" href="#Air.insert"><code>Air.insert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert(coll, idx, val)</code></pre><p>Yields a copy of the given collection <code>coll</code> with the given value <code>cal inserted at the given index. Roughly equivalent to insert!(copy(arr), idx, va): the</code>insert<code>function neve modifies its arguments and always yields a copy. For the persistent collections defined in Air, this operation is efficient, but for most mutable objects, this is</code>O(n)`.</p><p>See also: <code>Base.insert!</code>, <a href="#Air.push"><code>push</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K"><code>delete</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; insert((:a,:b,:c,:d), 2, :x)
(:a, :x, :b, :c, :d)</code></pre><pre><code class="language-julia-repl">julia&gt; u = [:a,:b,:c,:d]; insert(u, 1, :x)
5-element Array{Symbol,1}:
 :x
 :a
 :b
 :c
 :d

julia&gt; length(u)
4</code></pre><pre><code class="language-julia-repl">julia&gt; b = BitArray([0,0,0,0]); insert(b, 2, 1)
5-element BitArray{1}:
 0
 1
 0
 0
 0

julia&gt; b[2]
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL489-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.lockall" href="#Air.lockall"><code>Air.lockall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lockall(f, l1, l2, ...)</code></pre><p>Locks all of the lockable objects <code>l1</code>, <code>l2</code>, etc. then runs <code>f</code>, unlocks the objects, and returns the return value of <code>f()</code>.</p><p>See also: <code>Threads.ReentrantLock</code></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; (r1, r2, r3) = [ReentrantLock() for _ in 1:3]
       lockall(r1, r2, r3) do; :success end
:success

julia&gt; lockall([r1, r2, r3]) do; :success end
:success

julia&gt; lockall((r1, r2, r3)) do; :success end
:success</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/util.jl#LL478-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.lowmask-Union{Tuple{K}, Tuple{T}, Tuple{K,Type{T}}} where K&lt;:Integer where T&lt;:Unsigned" href="#Air.lowmask-Union{Tuple{K}, Tuple{T}, Tuple{K,Type{T}}} where K&lt;:Integer where T&lt;:Unsigned"><code>Air.lowmask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lowmask(bitno, T)
lowmask(bitno)</code></pre><p>Yields a mask of (unsigned integer) type T with all bits above the given bit number set to false and all bits below that number set to true. The bit itself is set to false. Bits are indexed starting at 0.</p><p>The default value of T is the PTree hash type (HASH_T).</p><p>lowmask(bitno) is equal to ~highmask(bitno).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.pop" href="#Air.pop"><code>Air.pop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pop(coll)</code></pre><p>Yields a tuple <code>(last, most)</code> where <code>last</code> is the last element of the given collection and most is a duplicate tuple of all but the last element of tup. This is basically a persistent equivalent to the <code>pop!</code> function that never modifies the given <code>coll</code>. For persistent collections in Air, these operations are efficient, but for most mutable types, it is <code>O(n)</code>.</p><pre><code class="language-none">pop(coll, key[, default])</code></pre><p>Similar to <code>pop!</code>, pops the specific <code>key</code> from the given collection <code>coll</code> and yields <code>(val, rest)</code> where <code>val</code> is the value associated with <code>key</code> in <code>coll</code> and <code>rest</code> is the remainder of the collection without <code>key</code>. If the <code>key</code> is not in <code>coll</code>, then <code>default</code> is yielded or an error is thrown.</p><p>See also: <code>Base.pop!</code>, <a href="#Air.push"><code>push</code></a>, <a href="#Air.popat"><code>popat</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K"><code>delete</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; pop((:a,:b,:c,:d))
(:d, (:a, :b, :c))

julia&gt; u = [:a,:b,:c,:d]; pop(u)
(:d, [:a, :b, :c])

julia&gt; length(u)
4

julia&gt; s = Set([:a, :b, :c]); pop(s, :c)
(:c, Set([:a, :b]))

julia&gt; :c in s
true</code></pre><pre><code class="language-julia-repl">julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 3); pop(d, :c)
(3, Dict(:a =&gt; 1,:b =&gt; 2))

julia&gt; d[:c]
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL256-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.popat" href="#Air.popat"><code>Air.popat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">popat(coll, k)</code></pre><p>Yields a tuple <code>(el, rest)</code> where <code>el</code> is the <code>k</code>th element of the given collection <code>coll</code> and <code>rest</code> is a duplicate of all but the <code>k</code>th element of <code>coll</code>. This is basically a persistent equivalent to the <code>popat!</code> function that never modifies the given <code>coll</code>. For persistent collections in Air, these operations are efficient, but for most mutable types, it is <code>O(n)</code>.</p><p>See also: <code>Base.popat!</code>, <a href="#Air.pop"><code>pop</code></a>, <a href="#Air.popfirst"><code>popfirst</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K"><code>delete</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; popat((:a,:b,:c,:d), 2)
(:b, (:a, :c, :d))

julia&gt; u = [:a,:b,:c,:d]; popat(u, 3)
(:c, [:a, :b, :d])

julia&gt; length(u)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL446-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.popfirst" href="#Air.popfirst"><code>Air.popfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">popfirst(coll)</code></pre><p>Yields a tuple <code>(first, rest)</code> where <code>first</code> is the first element of the given collection and rest is a duplicate tuple of all but the first element of <code>tup</code>. This is basically a persistent equivalent to the <code>popfirst!</code> function that never modifies the given <code>coll</code>. For persistent collections in Air, these operations are efficient, but for most mutable types, it is <code>O(n)</code>.</p><p>See also: <code>Base.popfirst!</code>, <a href="#Air.pushfirst"><code>pushfirst</code></a>, <a href="#Air.popat"><code>popat</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K"><code>delete</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; popfirst((:a,:b,:c,:d))
(:a, (:b, :c, :d))

julia&gt; u = [:a,:b,:c,:d]; popfirst(u)
(:a, [:b, :c, :d])

julia&gt; length(u)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL408-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_bitshift-Tuple{UInt64}" href="#Air.ptree_bitshift-Tuple{UInt64}"><code>Air.ptree_bitshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_bitshift(nodeid)</code></pre><p>Yields the bitshift for the given ptree node id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_cellindex!-Tuple{UInt64,UInt64,UInt64}" href="#Air.ptree_cellindex!-Tuple{UInt64,UInt64,UInt64}"><code>Air.ptree_cellindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_cellindex!(ptree, leafid)
ptree_cellindex!(nodeid, bits, leafid)</code></pre><p>Yields the index into the ptree&#39;s cell vector of the child containing the leaf with the given id. If the ptree does not contain the given leafid because the appropriate bit is not set then 0 is returned. However, unlike the function ptree_cellindex(), this function does not check whether or not the given leafid is in the set of possible children of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL294-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_cellindex-Tuple{UInt64,UInt64,UInt64}" href="#Air.ptree_cellindex-Tuple{UInt64,UInt64,UInt64}"><code>Air.ptree_cellindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_cellindex(ptree, leafid)
ptree_cellindex(nodeid, bits, leafid)</code></pre><p>Yields a tuple (present, bitindex, cellindex) in which [1] present is a boolean indicating whether a ptree containing the given leafid or the leaf itself is a child of the given ptree; [2] bitindex is the index into ptree&#39;s bits integer  for the given leaf, and cellindex is the inndex innto the ptree&#39;s cell array  where that child is or would be found. If the leafid is outside of the given ptree (i.e., it cannot exist beneath this ptree) then the cellindex returned returned is 0, but the bitindex will still match the appropriate shift for the ptree&#39;s depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL269-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_cellkey-Tuple{UInt64,UInt64}" href="#Air.ptree_cellkey-Tuple{UInt64,UInt64}"><code>Air.ptree_cellkey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_cellkey(ptree, childidx)</code></pre><p>Yields the leafid (a HASH_T value) of the key that goes with the particular child index that is given. This only works correctly for twig nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_depth-Tuple{UInt64}" href="#Air.ptree_depth-Tuple{UInt64}"><code>Air.ptree_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_depth(nodeaddr)</code></pre><p>Yields the depth of the node with the given node address. This depth is in the theoretical complete tree, not in the reified tree represented with memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_firstbit-Tuple{UInt64}" href="#Air.ptree_firstbit-Tuple{UInt64}"><code>Air.ptree_firstbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_firstbit(nodeid)</code></pre><p>Yields the first-bit for the given ptree node id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_highbitdiff-Tuple{UInt64,UInt64}" href="#Air.ptree_highbitdiff-Tuple{UInt64,UInt64}"><code>Air.ptree_highbitdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_highbitdiff(id1, id2)</code></pre><p>Yields the highest bit that is different between id1 and id2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_id-Tuple{Integer,Integer}" href="#Air.ptree_id-Tuple{Integer,Integer}"><code>Air.ptree_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_id(minleaf, depth)</code></pre><p>Yields the node-id for the node whose minimum leaf and depth are given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_isbeneath-Tuple{UInt64,UInt64}" href="#Air.ptree_isbeneath-Tuple{UInt64,UInt64}"><code>Air.ptree_isbeneath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_isbeneath(nodeid, leafid)</code></pre><p>Yields true if the given leafid can be found beneath the given node-id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_maxleaf-Tuple{UInt64}" href="#Air.ptree_maxleaf-Tuple{UInt64}"><code>Air.ptree_maxleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_maxleaf(nodeid)</code></pre><p>Yields the maximum child leaf index assiciated with the given nodeid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_minleaf-Tuple{UInt64}" href="#Air.ptree_minleaf-Tuple{UInt64}"><code>Air.ptree_minleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_minleaf(nodeid)</code></pre><p>Yields the minimum child leaf index associated with the given nodeid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_minmaxleaf-Tuple{UInt64}" href="#Air.ptree_minmaxleaf-Tuple{UInt64}"><code>Air.ptree_minmaxleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_minmaxleaf(nodeid)</code></pre><p>Yields the (min, max) child leaf index assiciated with the given nodeid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_parentid-Tuple{UInt64}" href="#Air.ptree_parentid-Tuple{UInt64}"><code>Air.ptree_parentid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_parentid(nodeid0)</code></pre><p>Yields the node-id of the parent of the given node. Note that node 0 (the tree&#39;s theoretical root) has no parent. If given a node id of 0, this function will return an arbitrary large number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_shift-Tuple{UInt64}" href="#Air.ptree_shift-Tuple{UInt64}"><code>Air.ptree_shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_shift(nodeid)</code></pre><p>Yields the shift for the given ptree node id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/ptree.jl#LL127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.push" href="#Air.push"><code>Air.push</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">push(coll, val)
push(coll1, val1, val2...)</code></pre><p>Yields a copy of the given collection <code>coll</code> with the given value <code>val</code> appended. This function is essentially a persistent equivalent of the <code>push!</code> function that never modifies the object <code>coll</code>. For persistent collections in  the Air library, this operation is efficient, but for most mutable objects, it is <code>O(n)</code>.</p><p>See also: <code>Base.push!</code>, <a href="#Air.pop"><code>pop</code></a>, <code>Base.setindex!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; push((:a,:b,:c,:d), :e)
(:a, :b, :c, :d, :e)</code></pre><pre><code class="language-julia-repl">julia&gt; u = [:a,:b,:c,:d]; push(u, :e)
5-element Array{Symbol,1}:
 :a
 :b
 :c
 :d
 :e</code></pre><pre><code class="language-julia-repl">julia&gt; s = Set([:a, :b, :c]); push(s, :d)
Set{Symbol} with 4 elements:
  :a
  :b
  :d
  :c</code></pre><pre><code class="language-julia-repl">julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2); push(d, :c =&gt; 3, :d =&gt; 4)
Dict{Symbol,Int64} with 4 entries:
  :a =&gt; 1
  :b =&gt; 2
  :d =&gt; 4
  :c =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL190-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.pushfirst" href="#Air.pushfirst"><code>Air.pushfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pushfirst(coll, val)
pushfirst(coll1, val1, val2...)</code></pre><p>Yields a copy of the given collection <code>coll</code> with the given value <code>val</code> prepended. This function is essentially a persistent equivalent of the <code>pushfirst!</code> function that never modifies the object <code>coll</code>. For persistent collections in the Air library, this operation is efficient, but for most mutable objects, it is <code>O(n)</code>.</p><p>See also: <code>Base.pushfirst!</code>, <a href="#Air.popfirst"><code>popfirst</code></a>, <code>Base.setindex!</code>, <a href="#Air.push"><code>push</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; pushfirst((:a,:b,:c,:d), :e)
(:e, :a, :b, :c, :d)

julia&gt; u = [:a,:b,:c,:d]; pushfirst(u, :e)
5-element Array{Symbol,1}:
 :e
 :a
 :b
 :c
 :d

julia&gt; length(u)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL362-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.receive-Union{Tuple{Source{T,K}}, Tuple{K}, Tuple{T}} where K where T" href="#Air.receive-Union{Tuple{Source{T,K}}, Tuple{K}, Tuple{T}} where K where T"><code>Air.receive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">receive(s)
receive(s, n)</code></pre><p>For a Source object s, yields the next value in its queue. Reading from a source in this way is thread-safe as long as it is done within a transaction. Inside of a transaction, all source reads are guaranteed to be sequential (i.e., not interrupted by other threads).</p><p>The second argument, n, may be passed, in which case, no matter what it is (even 1 or 0), a vector of the next n elements is returned; this receives each of them so they cannot be received later. In particular, you can receive(s, 0) to ensure that, during a transaction, no other thread processes anything from the source without actually reading from the source.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL1154-L1168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.reset-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},K}} where K where T" href="#Air.reset-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},K}} where K where T"><code>Air.reset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset(s, k)</code></pre><p>Resets a source object s with the new source kernel K (which must be of the same kernel type as s, and which may be the same kernel that s already has). This clears the error state from the source and allows it to be read again. Yields s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL1004-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T},S}} where S where T" href="#Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T},S}} where S where T"><code>Air.reset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset(actor, x)</code></pre><p>If the given actor is in an error state, this resets it, meaning it will start handling sent messages again, and gives it the new initial value x. Yields the actor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL981-L987">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.send-Tuple" href="#Air.send-Tuple"><code>Air.send</code></a> — <span class="docstring-category">Method</span></header><section><div><p>send(f, args...)</p><p>The send() method can be used to send a function to an actor. The actor may be the function f or it may be any of the args. When send() is called, it searches for the first occurance of an actor object in the argument list and dispatches on that actor. In the actual function call that is evaluated, the actor object is replaced with its stored value. The return value of the function becomes the new stored value of the actor.</p><p>When an actor is sent a function, the function is queued to be run in some other thread. The actor processes these threads synchronously.</p><p>If send() is called inside of a transaction, then the function is not immediately queued but rather is held until the transaction successfully completes. Once this happens, all sends are dispatched simultaneously such that two sends to the same actor during the same transaction will always run sequentially in the actor&#39;s thread.</p><p>Note that due to the design pattern described in the previous paragraph, one should never wait on the result of a function sent to an actor during a transaction. This might be done via a promise, for example, where the function sent to the actor delivers to a promise also sent to the actor. Because this function is not queued until the transaction is finished, and because the promise will never recieve an object until the function is queued, requesting the value of the promise will deadlock.</p><p>Note that the value of an actor when send() is does not make any guarantee about its value when the function that is sent gets evaluated–other messages may be processed in the interim.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL909-L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.setfilter!-Union{Tuple{T}, Tuple{Volatile{T},Function}} where T" href="#Air.setfilter!-Union{Tuple{T}, Tuple{Volatile{T},Function}} where T"><code>Air.setfilter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setfilter!(vol, fn)</code></pre><p>Sets the filter-function associated with the Volatile object vol. Any time that the vol is set (<code>vol[] = x</code>) the filter-function is called and the value saved in <code>vol</code> is instead <code>fn(x)</code>. This must be called within a transaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL821-L827">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.setfinalize!-Union{Tuple{T}, Tuple{Volatile{T},Function}} where T" href="#Air.setfinalize!-Union{Tuple{T}, Tuple{Volatile{T},Function}} where T"><code>Air.setfinalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setfinalize!(vol, fn)</code></pre><p>Sets the finalize-function associated with the Volatile object vol. Any time that a transaction contains a change to <code>vol</code>, immediately prior to making an attempt at committing the transaction, the finalize function is called and the value committed to <code>vol</code> is instead <code>fn(x)</code> where <code>x</code> is the value set to <code>vol</code> in the transaction. This funvtion must also be called within a transaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL831-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S,X}} where X&lt;:Number where S where D where F where W where T" href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S,X}} where X&lt;:Number where S where D where F where W where T"><code>Air.setweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setweight(h, x, w)</code></pre><p>Sets the weight of the value x in the given persistent heap or persistent weighted collection object h to be w and yields the new updated version of h. If x is not already in the object h, then an error is thrown.</p><p>See also: <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S}} where S where D where F where W where T"><code>getweight</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.PWSet"><code>PWSet</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; d = PWSet{Symbol}(:a =&gt; 1.0, :b =&gt; 2.0, :c =&gt; 3.0)
PWSet{Symbol,Float64} with 3 elements:
  :c
  :b
  :a

julia&gt; setweight(d, :a, 4.0)
PWSet{Symbol,Float64} with 3 elements:
  :a
  :c
  :b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/pheap.jl#LL190-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.take-Union{Tuple{Promise{T}}, Tuple{T}} where T" href="#Air.take-Union{Tuple{Promise{T}}, Tuple{T}} where T"><code>Air.take</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">take(promise)</code></pre><p>Yields the value delivered to the given <code>Promise</code> object after suspending the current thread to wait for the value if necessary.</p><p>See also <a href="#Air.Promise"><code>Promise</code></a>, <code>Base.put!</code>.</p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; p = Promise()
Promise{Any}(&lt;...&gt;)

julia&gt; put!(p, :done)
:done

julia&gt; p
Promise{Any}(:done)

julia&gt; take(p)
:done</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/util.jl#LL371-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.tx-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function" href="#Air.tx-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function"><code>Air.tx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tx(fn, args...)</code></pre><p>Runs the given function in a transaction and yields the result. The function fn is called as <code>fn(args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL587-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},S,Vararg{Any,N} where N}} where S where N where T" href="#Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},S,Vararg{Any,N} where N}} where S where N where T"><code>Base.setindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex(coll, val, index)</code></pre><p>Yields a copy of the given collection <code>coll</code> with the value <code>val</code> set at the given index. This is a persistent version of <code>setindex!</code> and works for most collection types including <code>Array</code>s, <code>Dict</code>s, <code>IdDict</code>s, and Air&#39;s persistent versions of these.</p><p>Note that setindex() <em>always</em> returns a copy of the argument <code>coll</code> or fails. For Air&#39;s persistent collections these operations are efficient, but for the mutable counterparts, they are typically <code>O(n)</code>.</p><p>See also: <code>Base.setindex!</code>, <a href="#Air.push"><code>push</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; setindex((:a,:b,:e,:d), :c, 3)
(:a, :b, :c, :d)</code></pre><pre><code class="language-julia-repl">julia&gt; u = [:a,:b,:e,:d]; v = setindex(u, :c, 3)
4-element Array{Symbol,1}:
 :a
 :b
 :c
 :d

julia&gt; u == v
false

julia&gt; u[3]
:e</code></pre><pre><code class="language-julia-repl">julia&gt; d1 = Dict(); setindex(d1, 10, :a)
Dict{Any,Any} with 1 entry:
  :a =&gt; 10

julia&gt; d1
Dict{Any,Any}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/api.jl#LL132-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.dropzeros-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T" href="#SparseArrays.dropzeros-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>SparseArrays.dropzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dropzeros(p::PArray)</code></pre><p>Drops explicit values of the given array <code>p</code> that are equal to the array&#39;s default value. This differs from the SparseArrays implementation of dropzeros() only in that <code>PArray</code>s allow arbitrary default values, while <code>SparseArray</code>s allow only the default value of zero.</p><p>Note that under most circumstances, a <code>PArrray</code> will not encode explicit zeros, so this function typically returns the object <code>p</code> untouched.</p><p>See also: <code>SparseArrays.nnz</code>, <code>SparseArrays.findnz</code>, <a href="#Air.PArray"><code>PArray</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; u = PVector{Int}([0,1,2,3])
4-element PArray{Int64,1}:
 0
 1
 2
 3

julia&gt; dropzeros(u) === u
true

julia&gt; v = setindex(u, 0, 3)
4-element PArray{Int64,1}:
 0
 1
 0
 3

julia&gt; dropzeros(v) === v
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/parray.jl#LL200-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.findnz-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T" href="#SparseArrays.findnz-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>SparseArrays.findnz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findnz(p::PArray)</code></pre><p>Yields the explicitly set elements of the given persistent array <code>p</code>. This method is identical to the typical SparseArrays implementation of findnz() except that it respects the arbitrary default-value that persistent arrays are allowed to have rather than assuming that this value is a zero, as is done in the <code>SparseArray</code>s library.</p><p>Note that under most circumstances, a <code>PArray</code> will not encode explicit zeros, so this function typically returns indices and values for all values that aren&#39;t equal to the default value of the array <code>p</code> (which is zero by default).</p><p>See also: <code>SparseArrays.nnz</code>, <a href="#Air.PArray"><code>PArray</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; u = PVector([0,10,20,30])
4-element PArray{Int64,1}:
  0
 10
 20
 30

julia&gt; findnz(u)
([1, 2, 3, 4], [0, 10, 20, 30])</code></pre><pre><code class="language-julia-repl">julia&gt; u = setindex(PVector(0.0, 4), 20, 2)
4-element PArray{Float64,1}:
  0.0
 20.0
  0.0
  0.0

julia&gt; findnz(u)
([2], [20.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/parray.jl#LL250-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nnz-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T" href="#SparseArrays.nnz-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>SparseArrays.nnz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nnz(p::PArray)</code></pre><p>Yields the number of explicitly set values in the persistent array p, regardless of the number that are zero. This is different from the sparse-array library only in that persistent arrays support arbitrary default values instead of supporting only the value zero. Thus this counts explicit values instead of non-zero values.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; u = PVector{Int}(0, (4,))
4-element PArray{Int64,1}:
 0
 0
 0
 0

julia&gt; v = setindex(u, 2, 3)
4-element PArray{Int64,1}:
 0
 0
 2
 0

julia&gt; nnz(v)
1

julia&gt; nnz(u)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/parray.jl#LL149-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nonzeros-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T" href="#SparseArrays.nonzeros-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>SparseArrays.nonzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nonzeros(p::PArray)</code></pre><p>Yields the explicitly set values of the given persistent array <code>p</code>. This method is identical to the typical <code>SparseArrays</code> implementation of <code>nonzeros()</code> for  its sparse array classes except that it returns a persistent array of values and that it respects the arbitrary default-value that persistent arrays are allowed to have rather than assuming that this value is a zero, as is done in the <code>SparseArrays</code> library.</p><p>Note that because <code>PArray</code>s don&#39;t typically store values equal to their default value explicitly, this will typically yield a vector of every non-default value in the array.</p><p>See also: <code>SparseArrays.findnz</code>, <code>SparseArrays.nnz</code>, <a href="#Air.PArray"><code>PArray</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; u = PVector([0,10,20,30])
4-element PArray{Int64,1}:
  0
 10
 20
 30

julia&gt; nonzeros(u)
4-element PArray{Int64,1}:
  0
 10
 20
 30</code></pre><pre><code class="language-julia-repl">julia&gt; u = setindex(PVector(0.0, 4), 20, 2)
4-element PArray{Float64,1}:
  0.0
 20.0
  0.0
  0.0

julia&gt; nonzeros(u)
1-element PArray{Float64,1}:
 20.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/parray.jl#LL313-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.@delay-Tuple{Expr}" href="#Air.@delay-Tuple{Expr}"><code>Air.@delay</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@delay expression</code></pre><p>Yields a <code>Delay</code> object that matches the given expression. The expression may be one of the following:</p><ol><li>A function of no arguments, such as <code>() -&gt; 10</code>; in this case the delay is made from this function (i.e., the RHS is the <code>-&gt;</code> expression that is delayed).</li><li>A function with a set of symbol arguments evaluates the RHS but uses a let statement to wrap all the symbols in the LHS into a closure.</li><li>An expression, which is treated as equivalent to <code>() -&gt; expression</code>.</li></ol><p>Optionally, the expression or LHS may be tagged with a type T. In this case, a <code>Delay{T}</code> object is yielded instead of a <code>Delay{Any}</code>.</p><p>See also: <a href="#Air.Delay"><code>Delay</code></a>, <a href="#Air.LazyDict"><code>LazyDict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; # Create a Delay with a long run time.
       d = (@delay (println(&quot;Running.&quot;); sleep(2); 10)::Int64)
Delay{Int64}(&lt;...&gt;)

julia&gt; # Start a few threads, each of which attempt to read it. The function will
       # only run once.
       for th in [(Threads.@spawn d[]) for _ in 1:5]; wait(th) end
Running.

julia&gt; # Ensure that it produced the correct value and doesn&#39;t run again.
       d[]
10

julia&gt; # The display now shows the realized value also.
       d
Delay{Int64}(10)

julia&gt; # Create a Delay with a locally-bound symbol.
       d2 = (@delay (d) -&gt; (d[] / 20.0)::Float64)
Delay{Float64}(&lt;...&gt;)

julia&gt; # We can rebind d without affecting d2.
       d = 10
10

julia&gt; d2[]
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/util.jl#LL73-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.@memoize-Tuple{Expr}" href="#Air.@memoize-Tuple{Expr}"><code>Air.@memoize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@memoize name(args...) = expr
@memoize name(args...) where {...} = expr</code></pre><p><code>@memoize</code> is a macro for declaring that the function declaration that follows should be memoized in a private dictionary and any pre-calculated value should be returned from that dictionary instead of being recalculated. All memoization is thread-safe: <code>expr</code> is only ever evaluated by one thread at a time, and is only ever evaluated once per unique set of arguments.</p><p>Note that arguments are memoized according to equality, so the use of mutable arguments can result in undefined behavior of those arguments are later changed.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; @memoize fib(n::Int) = begin
           println(&quot;Calculating fib($n)...&quot;)
           if n &lt; 1
               return 0
           elseif n == 1
               return 1
           else
               return fib(n-1) + fib(n - 2)
           end
       end::Int
fib (generic function with 1 method)

julia&gt; fib(5)
Calculating fib(5)...
Calculating fib(4)...
Calculating fib(3)...
Calculating fib(2)...
Calculating fib(1)...
Calculating fib(0)...
5

julia&gt; fib(6)
Calculating fib(6)...
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/util.jl#LL199-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.@tx-Tuple{Any}" href="#Air.@tx-Tuple{Any}"><code>Air.@tx</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@tx expr</code></pre><p>The macro @tx should be followed by an expression; that expression is run in an atomic transaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL740-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.@var-Tuple{Expr}" href="#Air.@var-Tuple{Expr}"><code>Air.@var</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@var</code></pre><p>Convenient syntax for creating a task-local Var object: <code>@var name = initval</code> will construct a Var object with the given initial value. <code>@var name = initval::T</code> will create a <code>Var{T}</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/049052fbe5601688396a969356a377629761e632/src/TX.jl#LL115-L121">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 20 March 2021 00:54">Saturday 20 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
