var documenterSearchIndex = {"docs":
[{"location":"#Air.jl","page":"Home","title":"Air.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Air]","category":"page"},{"location":"#Air.AbstractPArray","page":"Home","title":"Air.AbstractPArray","text":"AbstractPArray{T,N}\n\nThe Abstract persistent array type represents any Array-like type that is persistent. The Air library provides the reified type PArray{T,N}.\n\nSee also: PArray, PVector.\n\n\n\n\n\n","category":"type"},{"location":"#Air.AbstractPDict","page":"Home","title":"Air.AbstractPDict","text":"AbstractPDict{K,V}\n\nAbstractPDict is a subtype of AbstractDict that is extended only by persistent dictionary types such as PDict and LazyDict.\n\nSee also PDict, PWDict, LazyDict, PIdDict, LazyIdDict, PWIdDict.\n\n\n\n\n\n","category":"type"},{"location":"#Air.AbstractPSet","page":"Home","title":"Air.AbstractPSet","text":"AbstractPSet{T}\n\nAbstractPSet is an abstract type extended by persistent set types such as  PSet and `PWSet.\n\nSee also: PSet, PIdSet, PWSet, PWIdSet.\n\n\n\n\n\n","category":"type"},{"location":"#Air.AbstractPWDict","page":"Home","title":"Air.AbstractPWDict","text":"AbstractPWDict\n\nAbstractPWDict is a subtype of AbstractPDict that is overloaded by classes that represent weighted persistent dictionaries.\n\nSee also: AbstractPDict, PWDict, AbstractPWSet.\n\n\n\n\n\n","category":"type"},{"location":"#Air.AbstractPWSet","page":"Home","title":"Air.AbstractPWSet","text":"AbstractPWSet{T,W}\n\nAbstractPWSet is an abstract type implemented by all persistent weighted set types.\n\nSee also: PWSet, AbstractPSet.\n\n\n\n\n\n","category":"type"},{"location":"#Air.AbstractSourceKernel","page":"Home","title":"Air.AbstractSourceKernel","text":"AbtractSourceKernel{T}\n\nAn AbstractSourceKernel is an object that can be sampled to produce the next sample for a source. Objects of types descending from AbstractSourceKernel are not responsible for maintaining the multi-threaaded state exchange implied by sources; rather the represent a function that will be called discretely when samples are needed.\n\nSource kernels use the pop! function to get values. Once popped, values cannot be reobtained.\n\n\n\n\n\n","category":"type"},{"location":"#Air.Actor","page":"Home","title":"Air.Actor","text":"Actor{T}\n\nAn actor is an object that represents an worker-thread to which tasks can be scheduled. Any scheduled function is guaranteed to be evaluated at some point in the future in some other thread, and the return value of that function will become the new value held by the actor. Each function, when it is run, is passed the actor's value as one of its argument.\n\nLike with Refs, you can access an actor's current value using actor[]. Within a transaction, this will be guaranteed to remain fixed for the duration of the transaction; outside of a transaction, this may change at arbitrary times.\n\nActors may be initialized with post-processing functions. These functions are called immediately after executing any scheduled function and are given as their first argument the original agent value and as their second argument the return value of the scheduled function. Instead of saving this return value, the return value of the post-processing function is saved in the agent. This is useful for agents whose job is, for example, to serialize output to a log file being written to across many threads. If we run something like  send(log_agent, println, \"Some log message\") the println function will return nothing, which we would like to convert back into the log file so that subsequent send calls can continue to use the println fuction.\n\nActors may additionally be given an error handler. Whenever an exception occurs during a scheduled function, the error handler will be called with the arguments of (1) the agent object, (2) the current agent value, and (3) the exception that was caught. When an error has occurred, any attempt to schedule a function to the agent or to read from the agent will cause an exception to be raised. The error may be examined using actorerror(actor) and restarted using restart(actor).\n\nAll fields in an agent object should be considered strictly private. These fields are likely to change between releases, and changing the values will break your code.\n\n\n\n\n\n","category":"type"},{"location":"#Air.ActorException","page":"Home","title":"Air.ActorException","text":"ActorException{T}(error, value, argno, args)\n\nAn ActorException object is thrown whenever one attempts to obtain the value of or send a function to an actor that is in an error state. An error state occurs when an unhandled exception is raised while an actor is processing a sent function. In such a case the actorerror() and restart() functions may be used. The actorerror() function yields an ActorException object in which the exception that was raised is stored as error, the value of the actor when the send was run is stored in value, and the args and argno give the full contex of the send (i.e., the fucntion followed by the arguments in args and the argument number that corresponds to the actor in argno.\n\n\n\n\n\n","category":"type"},{"location":"#Air.Delay","page":"Home","title":"Air.Delay","text":"Delay{T}\n\nDelay objects can be used to lazily calculate a single value the first time it is requested. They act like Refs in that you access a delay d via d[]. Delay objects are thread-safe and are functionally immutable.\n\nSee also: @delay, LazyDict\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> # Create a Delay with a long run time.\n       d = Delay{Int64}(() -> (println(\"Running.\"); sleep(2); 10))\nDelay{Int64}(<...>)\n\njulia> # Start a few threads, each of which attempt to read it. The function\n       # will only run once.\n       for th in [(Threads.@spawn d[]) for _ in 1:5]; wait(th) end\nRunning.\n\njulia> # Ensure that it produced the correct value and doesn't run again.\n       d[]\n10\n\n\n\n\n\n","category":"type"},{"location":"#Air.FunctionSourceKernel","page":"Home","title":"Air.FunctionSourceKernel","text":"FunctionSourceKernel{T}\n\nA FunctionSourceKernel{T} object holds a function that is called every time a new source sample is needed.\n\n\n\n\n\n","category":"type"},{"location":"#Air.LazyDict","page":"Home","title":"Air.LazyDict","text":"LazyDict{K,V}\n\nA dictionay type equivalent to PDict{K,V} in every way except that for any value in the dict that is a Delay object, the dictionary hides the delay and always returns the delay's value. This allows any value that has not yet been requested to be lazily unevaluated.\n\nSee also: PDict, Base.Dict, LazyIdDict, Delay, @delay.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> LazyDict()\nLazyDict{Any,Any}()\n\njulia> LazyDict(:a => 1, :b => 2, :c => 12.8)\nLazyDict{Symbol,Real} with 3 entries:\n  :c => 12.8\n  :a => 1\n  :b => 2\n\njulia> d = LazyDict{Symbol,Float64}(:a => 1, :b => 2, :c => 12.8)\nLazyDict{Symbol,Float64} with 3 entries:\n  :c => 12.8\n  :a => 1.0\n  :b => 2.0\n\njulia> d2 = push(d, :d => Delay{Real}(() -> (println(\"Running...\"); 0.5))); haskey(d2, :d)\ntrue\n\njulia> d2[:d]\nRunning...\n0.5\n\njulia> d2[:d]\n0.5\n\n\n\n\n\n","category":"type"},{"location":"#Air.LazyIdDict","page":"Home","title":"Air.LazyIdDict","text":"LazyIdDict{K,V}\n\nA dictionay type equivalent to PIdDict{K,V} in every way except that for any value in the dict that is a Delay object, the dictionary hides the delay and always returns the delay's value. This allows any value that has not yet been requested to be lazily unevaluated.\n\nSee also: PIdDict, Base.IdDict, LazyDict, Delay, @delay.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> LazyIdDict()\nLazyIdDict{Any,Any}()\n\njulia> LazyIdDict(:a => 1, :b => 2, :c => 12.8)\nLazyIdDict{Symbol,Real} with 3 entries:\n  :b => 2\n  :a => 1\n  :c => 12.8\n\n```jldoctest; filter=r\"LazyIdDict{Symbol, ?Float64} with 3 entries:\" julia> d = LazyIdDict{Symbol,Float64}(:a => 1, :b => 2, :c => 12.8) LazyIdDict{Symbol,Float64} with 3 entries:   :c => 12.8   :a => 1.0   :b => 2.0\n\njulia> d2 = push(d, :d => Delay{Real}(() -> (println(\"Running...\"); 0.5))); haskey(d2, :d) true\n\njulia> d2[:d] Running... 0.5\n\njulia> d2[:d] 0.5\n\n\n\n\n\n","category":"type"},{"location":"#Air.PArray","page":"Home","title":"Air.PArray","text":"PArray{T,N}\n\nThe PArray type is a persistent/immutable corrolary to the Array{T,N} type. Like Array, PArray can store n-dimensional non-ragged arrays. However, unlike Arrays, PArrays can create duplicates of themselves with finite edits in log-time.\n\nPArrays have a similar interface as Arrays, but instead of the functions push!, pop!, and setindex!, PArrays use push, pop, and setindex. PArrays also have efficient implementations of pushfirst and popfirst.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PArray()\n0-element PArray{Any,1}\n\njulia> u = PArray{Int,1}([1,2])\n2-element PArray{Int64,1}:\n 1\n 2\n\njulia> push(u, 3)\n3-element PArray{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"type"},{"location":"#Air.PDict","page":"Home","title":"Air.PDict","text":"PDict{K,V}\n\nA dictionay type roughly equivalent to Dict{K,V} but that stores data using a persistent hash array mapped trie system that allows for efficient persistent operations. These operations are represented by non-mutating versions of the standard dictionary functions, such as setindex in place of setindex!, push in place of push!, and pop in place of pop!. These operations are performed in O(log n) time, and minimal data duplication is performed in  update operations.\n\nSee also: PIdDict, Dict, push, pop, setindex, delete, insert, getpair.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PDict()\nPDict{Any,Any}()\n\njulia> PDict(:a => 1, :b => 2, :c => 12.8)\nPDict{Symbol,Real} with 3 entries:\n  :c => 12.8\n  :a => 1\n  :b => 2\n\njulia> d = PDict{Symbol,Float64}(:a => 1, :b => 2, :c => 12.8)\nPDict{Symbol,Float64} with 3 entries:\n  :c => 12.8\n  :a => 1.0\n  :b => 2.0\n\njulia> :b in keys(d)\ntrue\n\njulia> d[:c]\n12.8\n\njulia> push(d, :d => 0.1)\nPDict{Symbol,Float64} with 4 entries:\n  :d => 0.1\n  :c => 12.8\n  :a => 1.0\n  :b => 2.0\n\n\n\n\n\n","category":"type"},{"location":"#Air.PHeap","page":"Home","title":"Air.PHeap","text":"PHeap{T,W,F}\n\nA PHeap object is a priority queue to which objects can be pushed and given a particular weight. PHeaps can then be iterated in weighted order, popped in weighted order, and the first  element may be obtained in weighted order. Additionally, a random sample may be drawn from a heap, which uses the distribution implied by the relative weights of the items in the heap.\n\nPHeap objects may be initialized with a single argument of type F <: Function, in which case this function is used to compare the weights for ordering. By default this is > such that high weights are retrieved first by the first() function and removed first by the pop() function. Note, however, that the relative weights are still used by the rand function regardless of the ordering function, so negative values cannot be used.\n\nSee also: PWSet, PWDict, pop, Base.first.\n\n\n\n\n\n","category":"type"},{"location":"#Air.PIdDict","page":"Home","title":"Air.PIdDict","text":"PIdDict{K,V}\n\nA dictionay type roughly equivalent to IdDict{K,V} but that stores data using a persistent hash array mapped trie system that allows for efficient persistent operations. These operations are represented by non-mutating versions of the standard dictionary functions, such as setindex in place of setindex!, push in place of push!, and pop in place of pop!. These operations are performed in O(log n) time, and minimal data duplication is performed in  update operations.\n\nSee also: PDict, Base.IdDict, push, pop, setindex, delete, insert, getpair.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PIdDict()\nPIdDict{Any,Any}()\n\n\njldoctest; filter=r\"PIdDict{Symbol, ?Real} with 3 entries:\" julia> PIdDict(:a => 1, :b => 2, :c => 12.8) PIdDict{Symbol,Real} with 3 entries:   :c => 12.8   :a => 1   :b => 2\n\n\n\njldoctest; filter=r\"PIdDict{Symbol, ?Float64} with [34] entries:\" julia> d = PIdDict{Symbol,Float64}(:a => 1, :b => 2, :c => 12.8) PIdDict{Symbol,Float64} with 3 entries:   :c => 12.8   :a => 1.0   :b => 2.0\n\njulia> :b in keys(d) true\n\njulia> d[:c] 12.8\n\njulia> push(d, :d => 0.1) PIdDict{Symbol,Float64} with 4 entries:   :d => 0.1   :c => 12.8   :a => 1.0   :b => 2.0\n\n\n\n\n\n","category":"type"},{"location":"#Air.PIdLinearDict","page":"Home","title":"Air.PIdLinearDict","text":"PIdLinearDict{K,V}\n\nAn identity-based persistent dict type that uses a simple array representation internally; accordingly PIdLinearDict does not peform persistent operations such as setindex, push, and delete efficiently. It is intended to be used by Air internally as a sub-dict that stores items whose hash values are identical.\n\nSee also: PLinearDict, PIdDict.\n\n\n\n\n\n","category":"type"},{"location":"#Air.PIdLinearSet","page":"Home","title":"Air.PIdLinearSet","text":"PIdLinearSet{T}\n\nA persistent IdSet type that uses a simple array representation internally; accordingly PIdLinearSet does not peform persistent operations such as setindex, push, and delete efficiently. It is intended to be used by Air internally as a set that stores items whose hash values are identical.\n\nSee also: PLinearSet, PSet.\n\n\n\n\n\n","category":"type"},{"location":"#Air.PIdSet","page":"Home","title":"Air.PIdSet","text":"PIdSet{T}\n\nA persistent identity-based set type that uses an array hash-mapped trie structure to allow for efficient updating of the set using the persistent operations defined by Air such as push, and delete.\n\nSee also: Set, PIdSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PIdSet()\nPIdSet{Any}()\n\njulia> :a in PIdSet([:a, :b, :c])\ntrue\n\njulia> :d in PIdSet([:a, :b, :c])\nfalse\n\njulia> :d in push(PIdSet(), :d)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#Air.PLinearDict","page":"Home","title":"Air.PLinearDict","text":"PLinearDict{K,V}\n\nA persistent dict type that uses a simple array representation internally; accordingly PLinearDict does not peform persistent operations such as setindex, push, and delete efficiently. It is intended to be used by Air internally as a sub-dict that stores items whose hash values are identical.\n\nSee also: PIdLinearDict, PDict.\n\n\n\n\n\n","category":"type"},{"location":"#Air.PLinearSet","page":"Home","title":"Air.PLinearSet","text":"PLinearSet{T}\n\nA persistent set type that uses a simple array representation internally; accordingly PLinearSet does not peform persistent operations such as setindex, push, and delete efficiently. It is intended to be used by Air internally as a set that stores items whose hash values are identical.\n\nSee also: PIdLinearSet, PSet.\n\n\n\n\n\n","category":"type"},{"location":"#Air.PMatrix","page":"Home","title":"Air.PMatrix","text":"PMatrix{T}\n\nAn alias for PArray{T,2}, representing a persistent matrix.\n\n\n\n\n\n","category":"type"},{"location":"#Air.PSet","page":"Home","title":"Air.PSet","text":"PSet{T}\n\nA persistent set type that uses an array hash-mapped trie structure to allow for efficient updating of the set using the persistent operations defined by Air such as setindex, push, and delete.\n\nSee also: Set, PIdSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PSet()\nPSet{Any}()\n\njulia> :a in PSet([:a, :b, :c])\ntrue\n\njulia> :d in PSet([:a, :b, :c])\nfalse\n\njulia> :d in push(PSet(), :d)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#Air.PTree","page":"Home","title":"Air.PTree","text":"PTree{T}\n\nPTree is a persistent tree/array hybrid that maps arbitrary unsigned integers (type HASH_T) to values. It can efficiently be used for arrays or for hash-maps, and supports efficient lookup, association, and dissociation.\n\nAll fields of a PTree should be considered strictly private, as modification of the fields may result in a kernel crash. The properties of a PTree are both immutable and safe to inpect.\n\n\n\n\n\n","category":"type"},{"location":"#Air.PVector","page":"Home","title":"Air.PVector","text":"PVector{T}\n\nAn alias for PArray{T,1}, representing a persistent vector.\n\n\n\n\n\n","category":"type"},{"location":"#Air.PWDict","page":"Home","title":"Air.PWDict","text":"PWDict{K,V}\n\nA persistent dictionary with weighted pairs. As such, a PWDict supports the typical operations of a PDict as well as the following:\n\nThe first function yields the key-value pair with the highest weight.\nThe pop function yields a copy of the dictionary without the pair that has the highest weight.\nIteration occurs in the order of greatest to least weight.\nThe weights can be changed with the getweight and setweight functions; setweight yields a duplicate dictionary with updated weights.\n\nSee also: PDict, getweight, setweight.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PWDict{Symbol,Int}(:a => (1,0.1), :b => (2, 0.2), :c => (3, 0.3))\nPWDict{Symbol,Int64,Float64} with 3 entries:\n  :c => 3\n  :b => 2\n  :a => 1\n\n\n\n\n\n","category":"type"},{"location":"#Air.PWIdDict","page":"Home","title":"Air.PWIdDict","text":"PWIdDict{K,V}\n\nA persistent dictionary with weighted pairs. As such, a PWIdDict supports the typical operations of a PIdDict as well as the following:\n\nThe first function yields the key-value pair with the highest weight.\nThe pop function yields a copy of the dictionary without the pair that has the highest weight.\nIteration occurs in the order of greatest to least weight.\nThe weights can be changed with the getweight and setweight functions; setweight yields a duplicate dictionary with updated weights.\n\nSee also: PIdDict, PWDict, getweight, setweight.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PWIdDict{Symbol,Int}(:a => (1,0.1), :b => (2, 0.2), :c => (3, 0.3))\nPWIdDict{Symbol,Int64,Float64} with 3 entries:\n  :c => 3\n  :b => 2\n  :a => 1\n\n\n\n\n\n","category":"type"},{"location":"#Air.PWIdSet","page":"Home","title":"Air.PWIdSet","text":"PWIdSet{T}\n\nA persistent set with weighted elements. As such, a PWIdSet supports the typical operations of a PIdSet as well as the following:\n\nThe first function yields the element with the highest weight.\nThe pop function yields a copy of the set without the element that has the highest weight.\nIteration occurs in the order of greatest to least weight.\nThe weights can be changed with the getweight and setweight functions; setweight yields a duplicate dictionary with updated weights.\n\nSee also: PIdSet, PWSet, getweight, setweight.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PWIdSet{Symbol}(:a => 0.1, :b => 0.2, :c => 0.3)\nPWIdSet{Symbol,Float64} with 3 elements:\n  :c\n  :b\n  :a\n\n\n\n\n\n","category":"type"},{"location":"#Air.PWSet","page":"Home","title":"Air.PWSet","text":"PWSet{K,V}\n\nA persistent set with weighted elements. As such, a PWSet supports the typical operations of a PSet as well as the following:\n\nThe first function yields the element with the highest weight.\nThe pop function yields a copy of the set without the element that has the highest weight.\nIteration occurs in the order of greatest to least weight.\nThe weights can be changed with the getweight and setweight functions; setweight yields a duplicate dictionary with updated weights.\n\nSee also: PSet, getweight, setweight.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PWSet{Symbol}(:a => 0.1, :b => 0.2, :c => 0.3)\nPWSet{Symbol,Float64} with 3 elements:\n  :c\n  :b\n  :a\n\n\n\n\n\n","category":"type"},{"location":"#Air.Promise","page":"Home","title":"Air.Promise","text":"Promise{T}\n\nPromise objects represent placeholders for values that may or may not have been delivered yet. This is effectively a Channel object that can only be put! to a single time and all take calls on the promise will return that value. Promise values can be accessed via the take() function (not the take!() function) or via p[] for promise p. In both cases, the running thread is suspended until a value is delivered.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> p = Promise{Symbol}()\nPromise{Symbol}(<...>)\n\njulia> isready(p)\nfalse\n\njulia> put!(p, :value)\n:value\n\njulia> isready(p)\ntrue\n\njulia> take(p)\n:value\n\njulia> p[]\n:value\n\n\n\n\n\n","category":"type"},{"location":"#Air.ReentrantRef","page":"Home","title":"Air.ReentrantRef","text":"ReentrantRef{T}\n\nA ReentrantRef is a type of ref object that is thread-safe. There are a few strategies for this, each of which are encoded in a different object type that inheits from ReentrantRef. These types are as follows.\n\nVar: Var objects act like Ref objects except that changes to them are exclusively task-local.\n\nActor: Actor objects obey the actor pattern; you can send(fn, actor, args...) where fn is a function that is, in another thread at some point, called as fn(actor[], args...). The new value of the actor after running fn is the return value of the call.\n\nVolatile: Volatile objects are refs that can be changed by any thread but that must be changed only within a synchronized transaction that ensures that all reads and writes of volatiles, as well as reads fom and sends to actors, are atomic: either they all happen successfully, or none of them do.\n\n\n\n\n\n","category":"type"},{"location":"#Air.Source","page":"Home","title":"Air.Source","text":"Source{T,K}\n\nSource objects work with transactions such that any samples taken from a source during a transaction either entirely occur or do not occur. I.e., if a transaction is rolled back or if an exception occurs during a transaction after a sampling from a source, then the sampling is rolled back.\n\nSources object their samples from Source kernel objects. The type parameter K must be the kernel type while T is the type parameter of type K (i.e., K is something like FunctionalSourceKernel{T}).\n\nSources can be sampled via the get() function. Althrough get() can be called either inside or outside of a transaction, when called inside of a transaction, the get is only performed when the transaction succeeds. Sources are thus safe to read from in transactions, unlike files and input streams.\n\n\n\n\n\n","category":"type"},{"location":"#Air.SourceAbortError","page":"Home","title":"Air.SourceAbortError","text":"SourceAbortError{T,K}\n\nA SourceAbortError is raised when a task is reading from a source (i.e., waiting for a source-kernel to pop a value) and a reset is issued to the source. In general this shouldn't happen because errors should only arise from the task waiting on the kernel itself.\n\n\n\n\n\n","category":"type"},{"location":"#Air.SourceKernelError","page":"Home","title":"Air.SourceKernelError","text":"SourceKernelError{T,K}\n\nA SourceKernelError is raised when an operation is attempted on a source whose kernel has raised an exception. The error of a source s may also be extracted via geterror(s).\n\nFor a SourceKernelError object err, err.source is the original source, err.task is the task that was attempting to read the actor when the error was caught, and err.error is the thrown object itself.\n\n\n\n\n\n","category":"type"},{"location":"#Air.SourceReadError","page":"Home","title":"Air.SourceReadError","text":"SourceReadError{T,K}\n\nSource read errors are generated when, during a transaction, is being read by multiple threads at once and becomes invalid for the current trasnaction. This is not really an error, and users should not encounter these exceptios; rather they should result in transaction retries.\n\n\n\n\n\n","category":"type"},{"location":"#Air.Transaction","page":"Home","title":"Air.Transaction","text":"Transaction\n\nA transaction object keeps track of what is going on during a particular transaction. These are generally low-level objects that shouldn't be touched directly.\n\n\n\n\n\n","category":"type"},{"location":"#Air.TransactionalRef","page":"Home","title":"Air.TransactionalRef","text":"TransactionalRef{T}\n\nA TransactionalRef is a reentrant ref that additional participates in transactions. Transactional refs include Actors and Volatiles.\n\n\n\n\n\n","category":"type"},{"location":"#Air.Var","page":"Home","title":"Air.Var","text":"Var{T}\n\nA Var object represents a task-local piece of data with a default value. You can access a var with var[] and you can set it with var[] = newval. However, the new assignment will always be task-local only. Because of this, Vars are safe to access and update in a multi-threaded program.\n\nAll fields of a Var should be considered strictly private.\n\n\n\n\n\n","category":"type"},{"location":"#Air.Volatile","page":"Home","title":"Air.Volatile","text":"Volatile{T}(value)\nVolatile{T}(value, filter_fn)\nvolatile{T}(value, filter_fn, finalize_fn)\n\nVolatile objects are Ref objects that must be used in conjunction with transaction blocks (see Air.@tx). The value of a Volatile can be accessed at any time, and there is no particular guarantee that a Volatile's value won't be changed by another thread outside of a transaction. Volatile objects can only be set inside of a transaction, however, and within a transaction, a Volatile's value is guaranteed to be constant.\n\nThe arguments filterfn and finnalizefn are functions for making sure that the value of a volatile conforms to some standard. The two functions are similar, but are intended for slightly different use cases:\n\nfilterfn is called every time the value of a volatile is set. The value saved in the volatile is filterfn(value) instead of value itself.\nfinnalizefn is called with the volatile's value immediately after the body of the transaction has completed, but before a commit is attempted. The finalizefnn function acts like the filterfn in that checkfn(value) replaces the value in the volatile.\n\nBoth filterfn and finalizefn can throw exceptions to abort the transaction.\n\nFor a volatile v, one may set v's stored value via v[] = value. This must be done inside a transaction (via tx or @tx). To change the filter or the finalize functions, use the setfilter! and setfinalize! functions, both of which also must be run in transactions as well.\n\n\n\n\n\n","category":"type"},{"location":"#Air._ActorMsg","page":"Home","title":"Air._ActorMsg","text":"_ActorMsg{T}\n\nThe (private) type of a message that is queued for an actor to eventually run.\n\n\n\n\n\n","category":"type"},{"location":"#Air._source_claim-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},UInt128,UInt128}} where K where T","page":"Home","title":"Air._source_claim","text":"_source_claim(s, start_pos, n)\n\nClaims the first n elements after the given source position startpost from the source s and updates the source object buffer to be free of those elements and the source position to be position + n. If the source position has been updated from startpos, a SourceReadError exception is thrown.\n\nIf n values have not already been ensured, then it is an error to call this function (i.e., it does not ensure the values, it just checks that the given start_pos is still equal to the source position).\n\n\n\n\n\n","category":"method"},{"location":"#Air._source_ensure-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},UInt128,Union{Nothing, UInt128}}} where K where T","page":"Home","title":"Air._source_ensure","text":"_source_ensure(s, n)\n\nEnsures that the source s contains at least n items in its queue then yields a tuple (position, firstn) where position is the current stream position and firstn is the vector of the first n stream elements.\n\nThe condition for source s must not be locked when this is called.\n\nIf the start position moves out from underneath the source as it is waiting on the kernel, then a SourceReadError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"#Air.current_tx-Tuple{}","page":"Home","title":"Air.current_tx","text":"current_tx()\n\nYields the current transaction, or nothing if there is no transaction running.\n\n\n\n\n\n","category":"method"},{"location":"#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K,V},J}} where J where V where K","page":"Home","title":"Air.delete","text":"delete(coll, k)\n\nYields a copy of the collection coll with the item associated with the given index or key k deleted. This function works on dictionaries, vectors, tuples, and sets, and it always yields a copy of the collection without modifying its aguments. For the persistent collections defined in Air, this is efficient, but for most mutable objects, this is O(n).\n\nSee also: Base.delete!, insert, pop.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> delete((:a,:b,:c,:d), 2)\n(:a, :c, :d)\n\njulia> u = [:a,:b,:c,:d]; delete(u, 1)\n3-element Array{Symbol,1}:\n :b\n :c\n :d\n\njulia> s1 = Set([:a,:b,:c,:d]); s2 = delete(s1, :d); (:d in s1, :d in s2)\n(true, false)\n\njulia> b = BitArray([0,0,0,1,0]); delete(b, 4)\n4-element BitArray{1}:\n 0\n 0\n 0\n 0\n\njulia> b[2]\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Air.depth_to_bitshift-Tuple{Integer}","page":"Home","title":"Air.depth_to_bitshift","text":"depth_to_bitshift(depth)\n\nYields the tuple (B0,S) of the first bit index and the shift for the given depth.\n\n\n\n\n\n","category":"method"},{"location":"#Air.equalfn-Tuple{T} where T","page":"Home","title":"Air.equalfn","text":"equalfn(x)\n\nIf x is an object (such as a PSet or Dict) that has an opinion about equality, equalfn(x) returns the function that it uses.\n\nSee also: hashfn\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> equalfn(Dict) == isequal\ntrue\n\njulia> equalfn(IdDict) == (===)\ntrue\n\njulia> equalfn(PSet) == isequal\ntrue\n\njulia> equalfn(PArray)\nERROR: ArgumentError: no equalfn for type PArray\n\n\n\n\n\n","category":"method"},{"location":"#Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T","page":"Home","title":"Air.geterror","text":"getrerror(actor)\n\nIf the given actor object is currently in an error state, then yields the ActorException object that describes the error. Otherwise, yields nothing.\n\n\n\n\n\n","category":"method"},{"location":"#Air.geterror-Union{Tuple{Source{T,K}}, Tuple{K}, Tuple{T}} where K where T","page":"Home","title":"Air.geterror","text":"geterror(s)\n\nYields the error raised by the source-kernel for the source object s if s is in an error-state; otherwise yields nothing.\n\n\n\n\n\n","category":"method"},{"location":"#Air.getfilter-Union{Tuple{Volatile{T}}, Tuple{T}} where T","page":"Home","title":"Air.getfilter","text":"getfilter(v)\n\nYields the filter-function for the volatile v.\n\n\n\n\n\n","category":"method"},{"location":"#Air.getfinalize-Union{Tuple{Volatile{T}}, Tuple{T}} where T","page":"Home","title":"Air.getfinalize","text":"getfinalize(v)\n\nYields the finalize-function for the volatile v.\n\n\n\n\n\n","category":"method"},{"location":"#Air.getpair","page":"Home","title":"Air.getpair","text":"getpair(d, k)\n\nIf the key k is found in the dictionary d, yields the pair (k => d[k]); otherwise yields missing.\n\nSee also: Base.get, Base.getindex.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> d = Dict(:a => 1, :b => 2, :c => 3); getpair(d, :a)\n:a => 1\n\njulia> getpair(d, :x)\nmissing\n\n\n\n\n\n","category":"function"},{"location":"#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S}} where S where D where F where W where T","page":"Home","title":"Air.getweight","text":"getweight(h, x)\n\nYields the weight for the given value x in the given persistent heap or persistent weighted collection h. If h is a weighted dictionary, then x should be the key.\n\nIf the key or object x is not found in the collection h, then 0 is returned.\n\nSee also: setweight, PWDict, PWSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> d = PWSet{Symbol}(:a => 1.0, :b => 2.0, :c => 3.0)\nPWSet{Symbol,Float64} with 3 elements:\n  :c\n  :b\n  :a\n\njulia> getweight(d, :a)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"#Air.hashfn-Tuple{T} where T","page":"Home","title":"Air.hashfn","text":"hashfn(x)\n\nIf x is an object (such as a PSet or Dict) that has an opinion about how it hashes objects, hashfn(x) returns the function that it uses. It is sufficient in almost all circumstances to define equalfn(T); the hashfn should always match the equalfn regardless.\n\nSee also: equalfn\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> hashfn(Dict) == hash\ntrue\n\njulia> hashfn(IdDict) == objectid\ntrue\n\njulia> hashfn(PSet) == hash\ntrue\n\njulia> hashfn(PArray)\nERROR: ArgumentError: no equalfn for type PArray\n\n\n\n\n\n","category":"method"},{"location":"#Air.highmask-Union{Tuple{K}, Tuple{T}, Tuple{K,Type{T}}} where K<:Integer where T<:Unsigned","page":"Home","title":"Air.highmask","text":"highmask(bitno, T)\nhighmask(bitno)\n\nYields a mask of (unsigned integer) type T with all bits above the given bit number set to true and all bits below that number set to false. The bit itself is set to true. Bits are indexed starting at 0.\n\nThe default value of T is the PTree hash type (HASH_T).\n\nhighmask(bitno) is equal to ~lowmask(bitno).\n\n\n\n\n\n","category":"method"},{"location":"#Air.insert","page":"Home","title":"Air.insert","text":"insert(coll, idx, val)\n\nYields a copy of the given collection coll with the given value cal inserted at the given index. Roughly equivalent to insert!(copy(arr), idx, va): theinsertfunction neve modifies its arguments and always yields a copy. For the persistent collections defined in Air, this operation is efficient, but for most mutable objects, this isO(n)`.\n\nSee also: Base.insert!, push, delete.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> insert((:a,:b,:c,:d), 2, :x)\n(:a, :x, :b, :c, :d)\n\njulia> u = [:a,:b,:c,:d]; insert(u, 1, :x)\n5-element Array{Symbol,1}:\n :x\n :a\n :b\n :c\n :d\n\njulia> length(u)\n4\n\njulia> b = BitArray([0,0,0,0]); insert(b, 2, 1)\n5-element BitArray{1}:\n 0\n 1\n 0\n 0\n 0\n\njulia> b[2]\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#Air.lockall","page":"Home","title":"Air.lockall","text":"lockall(f, l1, l2, ...)\n\nLocks all of the lockable objects l1, l2, etc. then runs f, unlocks the objects, and returns the return value of f().\n\nSee also: Threads.ReentrantLock\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> (r1, r2, r3) = [ReentrantLock() for _ in 1:3]\n       lockall(r1, r2, r3) do; :success end\n:success\n\njulia> lockall([r1, r2, r3]) do; :success end\n:success\n\njulia> lockall((r1, r2, r3)) do; :success end\n:success\n\n\n\n\n\n","category":"function"},{"location":"#Air.lowmask-Union{Tuple{K}, Tuple{T}, Tuple{K,Type{T}}} where K<:Integer where T<:Unsigned","page":"Home","title":"Air.lowmask","text":"lowmask(bitno, T)\nlowmask(bitno)\n\nYields a mask of (unsigned integer) type T with all bits above the given bit number set to false and all bits below that number set to true. The bit itself is set to false. Bits are indexed starting at 0.\n\nThe default value of T is the PTree hash type (HASH_T).\n\nlowmask(bitno) is equal to ~highmask(bitno).\n\n\n\n\n\n","category":"method"},{"location":"#Air.pop","page":"Home","title":"Air.pop","text":"pop(coll)\n\nYields a tuple (last, most) where last is the last element of the given collection and most is a duplicate tuple of all but the last element of tup. This is basically a persistent equivalent to the pop! function that never modifies the given coll. For persistent collections in Air, these operations are efficient, but for most mutable types, it is O(n).\n\npop(coll, key[, default])\n\nSimilar to pop!, pops the specific key from the given collection coll and yields (val, rest) where val is the value associated with key in coll and rest is the remainder of the collection without key. If the key is not in coll, then default is yielded or an error is thrown.\n\nSee also: Base.pop!, push, popat, delete.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> pop((:a,:b,:c,:d))\n(:d, (:a, :b, :c))\n\njulia> u = [:a,:b,:c,:d]; pop(u)\n(:d, [:a, :b, :c])\n\njulia> length(u)\n4\n\njulia> s = Set([:a, :b, :c]); pop(s, :c)\n(:c, Set([:a, :b]))\n\njulia> :c in s\ntrue\n\njulia> d = Dict(:a => 1, :b => 2, :c => 3); pop(d, :c)\n(3, Dict(:a => 1,:b => 2))\n\njulia> d[:c]\n3\n\n\n\n\n\n","category":"function"},{"location":"#Air.popat","page":"Home","title":"Air.popat","text":"popat(coll, k)\n\nYields a tuple (el, rest) where el is the kth element of the given collection coll and rest is a duplicate of all but the kth element of coll. This is basically a persistent equivalent to the popat! function that never modifies the given coll. For persistent collections in Air, these operations are efficient, but for most mutable types, it is O(n).\n\nSee also: Base.popat!, pop, popfirst, delete.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> popat((:a,:b,:c,:d), 2)\n(:b, (:a, :c, :d))\n\njulia> u = [:a,:b,:c,:d]; popat(u, 3)\n(:c, [:a, :b, :d])\n\njulia> length(u)\n4\n\n\n\n\n\n","category":"function"},{"location":"#Air.popfirst","page":"Home","title":"Air.popfirst","text":"popfirst(coll)\n\nYields a tuple (first, rest) where first is the first element of the given collection and rest is a duplicate tuple of all but the first element of tup. This is basically a persistent equivalent to the popfirst! function that never modifies the given coll. For persistent collections in Air, these operations are efficient, but for most mutable types, it is O(n).\n\nSee also: Base.popfirst!, pushfirst, popat, delete.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> popfirst((:a,:b,:c,:d))\n(:a, (:b, :c, :d))\n\njulia> u = [:a,:b,:c,:d]; popfirst(u)\n(:a, [:b, :c, :d])\n\njulia> length(u)\n4\n\n\n\n\n\n","category":"function"},{"location":"#Air.ptree_bitshift-Tuple{UInt64}","page":"Home","title":"Air.ptree_bitshift","text":"ptree_bitshift(nodeid)\n\nYields the bitshift for the given ptree node id.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_cellindex!-Tuple{UInt64,UInt64,UInt64}","page":"Home","title":"Air.ptree_cellindex!","text":"ptree_cellindex!(ptree, leafid)\nptree_cellindex!(nodeid, bits, leafid)\n\nYields the index into the ptree's cell vector of the child containing the leaf with the given id. If the ptree does not contain the given leafid because the appropriate bit is not set then 0 is returned. However, unlike the function ptree_cellindex(), this function does not check whether or not the given leafid is in the set of possible children of the tree.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_cellindex-Tuple{UInt64,UInt64,UInt64}","page":"Home","title":"Air.ptree_cellindex","text":"ptree_cellindex(ptree, leafid)\nptree_cellindex(nodeid, bits, leafid)\n\nYields a tuple (present, bitindex, cellindex) in which [1] present is a boolean indicating whether a ptree containing the given leafid or the leaf itself is a child of the given ptree; [2] bitindex is the index into ptree's bits integer  for the given leaf, and cellindex is the inndex innto the ptree's cell array  where that child is or would be found. If the leafid is outside of the given ptree (i.e., it cannot exist beneath this ptree) then the cellindex returned returned is 0, but the bitindex will still match the appropriate shift for the ptree's depth.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_cellkey-Tuple{UInt64,UInt64}","page":"Home","title":"Air.ptree_cellkey","text":"ptree_cellkey(ptree, childidx)\n\nYields the leafid (a HASH_T value) of the key that goes with the particular child index that is given. This only works correctly for twig nodes.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_depth-Tuple{UInt64}","page":"Home","title":"Air.ptree_depth","text":"ptree_depth(nodeaddr)\n\nYields the depth of the node with the given node address. This depth is in the theoretical complete tree, not in the reified tree represented with memory.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_firstbit-Tuple{UInt64}","page":"Home","title":"Air.ptree_firstbit","text":"ptree_firstbit(nodeid)\n\nYields the first-bit for the given ptree node id.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_highbitdiff-Tuple{UInt64,UInt64}","page":"Home","title":"Air.ptree_highbitdiff","text":"ptree_highbitdiff(id1, id2)\n\nYields the highest bit that is different between id1 and id2.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_id-Tuple{Integer,Integer}","page":"Home","title":"Air.ptree_id","text":"ptree_id(minleaf, depth)\n\nYields the node-id for the node whose minimum leaf and depth are given.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_isbeneath-Tuple{UInt64,UInt64}","page":"Home","title":"Air.ptree_isbeneath","text":"ptree_isbeneath(nodeid, leafid)\n\nYields true if the given leafid can be found beneath the given node-id.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_maxleaf-Tuple{UInt64}","page":"Home","title":"Air.ptree_maxleaf","text":"ptree_maxleaf(nodeid)\n\nYields the maximum child leaf index assiciated with the given nodeid.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_minleaf-Tuple{UInt64}","page":"Home","title":"Air.ptree_minleaf","text":"ptree_minleaf(nodeid)\n\nYields the minimum child leaf index associated with the given nodeid.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_minmaxleaf-Tuple{UInt64}","page":"Home","title":"Air.ptree_minmaxleaf","text":"ptree_minmaxleaf(nodeid)\n\nYields the (min, max) child leaf index assiciated with the given nodeid.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_parentid-Tuple{UInt64}","page":"Home","title":"Air.ptree_parentid","text":"ptree_parentid(nodeid0)\n\nYields the node-id of the parent of the given node. Note that node 0 (the tree's theoretical root) has no parent. If given a node id of 0, this function will return an arbitrary large number.\n\n\n\n\n\n","category":"method"},{"location":"#Air.ptree_shift-Tuple{UInt64}","page":"Home","title":"Air.ptree_shift","text":"ptree_shift(nodeid)\n\nYields the shift for the given ptree node id.\n\n\n\n\n\n","category":"method"},{"location":"#Air.push","page":"Home","title":"Air.push","text":"push(coll, val)\npush(coll1, val1, val2...)\n\nYields a copy of the given collection coll with the given value val appended. This function is essentially a persistent equivalent of the push! function that never modifies the object coll. For persistent collections in  the Air library, this operation is efficient, but for most mutable objects, it is O(n).\n\nSee also: Base.push!, pop, Base.setindex!.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> push((:a,:b,:c,:d), :e)\n(:a, :b, :c, :d, :e)\n\njulia> u = [:a,:b,:c,:d]; push(u, :e)\n5-element Array{Symbol,1}:\n :a\n :b\n :c\n :d\n :e\n\njulia> s = Set([:a, :b, :c]); push(s, :d)\nSet{Symbol} with 4 elements:\n  :a\n  :b\n  :d\n  :c\n\njulia> d = Dict(:a => 1, :b => 2); push(d, :c => 3, :d => 4)\nDict{Symbol,Int64} with 4 entries:\n  :a => 1\n  :b => 2\n  :d => 4\n  :c => 3\n\n\n\n\n\n","category":"function"},{"location":"#Air.pushfirst","page":"Home","title":"Air.pushfirst","text":"pushfirst(coll, val)\npushfirst(coll1, val1, val2...)\n\nYields a copy of the given collection coll with the given value val prepended. This function is essentially a persistent equivalent of the pushfirst! function that never modifies the object coll. For persistent collections in the Air library, this operation is efficient, but for most mutable objects, it is O(n).\n\nSee also: Base.pushfirst!, popfirst, Base.setindex!, push.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> pushfirst((:a,:b,:c,:d), :e)\n(:e, :a, :b, :c, :d)\n\njulia> u = [:a,:b,:c,:d]; pushfirst(u, :e)\n5-element Array{Symbol,1}:\n :e\n :a\n :b\n :c\n :d\n\njulia> length(u)\n4\n\n\n\n\n\n","category":"function"},{"location":"#Air.receive-Union{Tuple{Source{T,K}}, Tuple{K}, Tuple{T}} where K where T","page":"Home","title":"Air.receive","text":"receive(s)\nreceive(s, n)\n\nFor a Source object s, yields the next value in its queue. Reading from a source in this way is thread-safe as long as it is done within a transaction. Inside of a transaction, all source reads are guaranteed to be sequential (i.e., not interrupted by other threads).\n\nThe second argument, n, may be passed, in which case, no matter what it is (even 1 or 0), a vector of the next n elements is returned; this receives each of them so they cannot be received later. In particular, you can receive(s, 0) to ensure that, during a transaction, no other thread processes anything from the source without actually reading from the source.\n\n\n\n\n\n","category":"method"},{"location":"#Air.reset-Union{Tuple{K}, Tuple{T}, Tuple{Source{T,K},K}} where K where T","page":"Home","title":"Air.reset","text":"reset(s, k)\n\nResets a source object s with the new source kernel K (which must be of the same kernel type as s, and which may be the same kernel that s already has). This clears the error state from the source and allows it to be read again. Yields s.\n\n\n\n\n\n","category":"method"},{"location":"#Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T},S}} where S where T","page":"Home","title":"Air.reset","text":"reset(actor, x)\n\nIf the given actor is in an error state, this resets it, meaning it will start handling sent messages again, and gives it the new initial value x. Yields the actor.\n\n\n\n\n\n","category":"method"},{"location":"#Air.send-Tuple","page":"Home","title":"Air.send","text":"send(f, args...)\n\nThe send() method can be used to send a function to an actor. The actor may be the function f or it may be any of the args. When send() is called, it searches for the first occurance of an actor object in the argument list and dispatches on that actor. In the actual function call that is evaluated, the actor object is replaced with its stored value. The return value of the function becomes the new stored value of the actor.\n\nWhen an actor is sent a function, the function is queued to be run in some other thread. The actor processes these threads synchronously.\n\nIf send() is called inside of a transaction, then the function is not immediately queued but rather is held until the transaction successfully completes. Once this happens, all sends are dispatched simultaneously such that two sends to the same actor during the same transaction will always run sequentially in the actor's thread.\n\nNote that due to the design pattern described in the previous paragraph, one should never wait on the result of a function sent to an actor during a transaction. This might be done via a promise, for example, where the function sent to the actor delivers to a promise also sent to the actor. Because this function is not queued until the transaction is finished, and because the promise will never recieve an object until the function is queued, requesting the value of the promise will deadlock.\n\nNote that the value of an actor when send() is does not make any guarantee about its value when the function that is sent gets evaluated–other messages may be processed in the interim.\n\n\n\n\n\n","category":"method"},{"location":"#Air.setfilter!-Union{Tuple{T}, Tuple{Volatile{T},Function}} where T","page":"Home","title":"Air.setfilter!","text":"setfilter!(vol, fn)\n\nSets the filter-function associated with the Volatile object vol. Any time that the vol is set (vol[] = x) the filter-function is called and the value saved in vol is instead fn(x). This must be called within a transaction.\n\n\n\n\n\n","category":"method"},{"location":"#Air.setfinalize!-Union{Tuple{T}, Tuple{Volatile{T},Function}} where T","page":"Home","title":"Air.setfinalize!","text":"setfinalize!(vol, fn)\n\nSets the finalize-function associated with the Volatile object vol. Any time that a transaction contains a change to vol, immediately prior to making an attempt at committing the transaction, the finalize function is called and the value committed to vol is instead fn(x) where x is the value set to vol in the transaction. This funvtion must also be called within a transaction.\n\n\n\n\n\n","category":"method"},{"location":"#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T,W,F,D},S,X}} where X<:Number where S where D where F where W where T","page":"Home","title":"Air.setweight","text":"setweight(h, x, w)\n\nSets the weight of the value x in the given persistent heap or persistent weighted collection object h to be w and yields the new updated version of h. If x is not already in the object h, then an error is thrown.\n\nSee also: getweight, PWDict, PWSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> d = PWSet{Symbol}(:a => 1.0, :b => 2.0, :c => 3.0)\nPWSet{Symbol,Float64} with 3 elements:\n  :c\n  :b\n  :a\n\njulia> setweight(d, :a, 4.0)\nPWSet{Symbol,Float64} with 3 elements:\n  :a\n  :c\n  :b\n\n\n\n\n\n","category":"method"},{"location":"#Air.take-Union{Tuple{Promise{T}}, Tuple{T}} where T","page":"Home","title":"Air.take","text":"take(promise)\n\nYields the value delivered to the given Promise object after suspending the current thread to wait for the value if necessary.\n\nSee also Promise, Base.put!.\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> p = Promise()\nPromise{Any}(<...>)\n\njulia> put!(p, :done)\n:done\n\njulia> p\nPromise{Any}(:done)\n\njulia> take(p)\n:done\n\n\n\n\n\n","category":"method"},{"location":"#Air.tx-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F<:Function","page":"Home","title":"Air.tx","text":"tx(fn, args...)\n\nRuns the given function in a transaction and yields the result. The function fn is called as fn(args...).\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},S,Vararg{Any,N} where N}} where S where N where T","page":"Home","title":"Base.setindex","text":"setindex(coll, val, index)\n\nYields a copy of the given collection coll with the value val set at the given index. This is a persistent version of setindex! and works for most collection types including Arrays, Dicts, IdDicts, and Air's persistent versions of these.\n\nNote that setindex() always returns a copy of the argument coll or fails. For Air's persistent collections these operations are efficient, but for the mutable counterparts, they are typically O(n).\n\nSee also: Base.setindex!, push.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> setindex((:a,:b,:e,:d), :c, 3)\n(:a, :b, :c, :d)\n\njulia> u = [:a,:b,:e,:d]; v = setindex(u, :c, 3)\n4-element Array{Symbol,1}:\n :a\n :b\n :c\n :d\n\njulia> u == v\nfalse\n\njulia> u[3]\n:e\n\njulia> d1 = Dict(); setindex(d1, 10, :a)\nDict{Any,Any} with 1 entry:\n  :a => 10\n\njulia> d1\nDict{Any,Any}()\n\n\n\n\n\n","category":"method"},{"location":"#SparseArrays.dropzeros-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T","page":"Home","title":"SparseArrays.dropzeros","text":"dropzeros(p::PArray)\n\nDrops explicit values of the given array p that are equal to the array's default value. This differs from the SparseArrays implementation of dropzeros() only in that PArrays allow arbitrary default values, while SparseArrays allow only the default value of zero.\n\nNote that under most circumstances, a PArrray will not encode explicit zeros, so this function typically returns the object p untouched.\n\nSee also: SparseArrays.nnz, SparseArrays.findnz, PArray.\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> u = PVector{Int}([0,1,2,3])\n4-element PArray{Int64,1}:\n 0\n 1\n 2\n 3\n\njulia> dropzeros(u) === u\ntrue\n\njulia> v = setindex(u, 0, 3)\n4-element PArray{Int64,1}:\n 0\n 1\n 0\n 3\n\njulia> dropzeros(v) === v\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#SparseArrays.findnz-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T","page":"Home","title":"SparseArrays.findnz","text":"findnz(p::PArray)\n\nYields the explicitly set elements of the given persistent array p. This method is identical to the typical SparseArrays implementation of findnz() except that it respects the arbitrary default-value that persistent arrays are allowed to have rather than assuming that this value is a zero, as is done in the SparseArrays library.\n\nNote that under most circumstances, a PArray will not encode explicit zeros, so this function typically returns indices and values for all values that aren't equal to the default value of the array p (which is zero by default).\n\nSee also: SparseArrays.nnz, PArray.\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> u = PVector([0,10,20,30])\n4-element PArray{Int64,1}:\n  0\n 10\n 20\n 30\n\njulia> findnz(u)\n([1, 2, 3, 4], [0, 10, 20, 30])\n\njulia> u = setindex(PVector(0.0, 4), 20, 2)\n4-element PArray{Float64,1}:\n  0.0\n 20.0\n  0.0\n  0.0\n\njulia> findnz(u)\n([2], [20.0])\n\n\n\n\n\n","category":"method"},{"location":"#SparseArrays.nnz-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T","page":"Home","title":"SparseArrays.nnz","text":"nnz(p::PArray)\n\nYields the number of explicitly set values in the persistent array p, regardless of the number that are zero. This is different from the sparse-array library only in that persistent arrays support arbitrary default values instead of supporting only the value zero. Thus this counts explicit values instead of non-zero values.\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> u = PVector{Int}(0, (4,))\n4-element PArray{Int64,1}:\n 0\n 0\n 0\n 0\n\njulia> v = setindex(u, 2, 3)\n4-element PArray{Int64,1}:\n 0\n 0\n 2\n 0\n\njulia> nnz(v)\n1\n\njulia> nnz(u)\n0\n\n\n\n\n\n","category":"method"},{"location":"#SparseArrays.nonzeros-Union{Tuple{PArray{T,N}}, Tuple{N}, Tuple{T}} where N where T","page":"Home","title":"SparseArrays.nonzeros","text":"nonzeros(p::PArray)\n\nYields the explicitly set values of the given persistent array p. This method is identical to the typical SparseArrays implementation of nonzeros() for  its sparse array classes except that it returns a persistent array of values and that it respects the arbitrary default-value that persistent arrays are allowed to have rather than assuming that this value is a zero, as is done in the SparseArrays library.\n\nNote that because PArrays don't typically store values equal to their default value explicitly, this will typically yield a vector of every non-default value in the array.\n\nSee also: SparseArrays.findnz, SparseArrays.nnz, PArray.\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> u = PVector([0,10,20,30])\n4-element PArray{Int64,1}:\n  0\n 10\n 20\n 30\n\njulia> nonzeros(u)\n4-element PArray{Int64,1}:\n  0\n 10\n 20\n 30\n\njulia> u = setindex(PVector(0.0, 4), 20, 2)\n4-element PArray{Float64,1}:\n  0.0\n 20.0\n  0.0\n  0.0\n\njulia> nonzeros(u)\n1-element PArray{Float64,1}:\n 20.0\n\n\n\n\n\n","category":"method"},{"location":"#Air.@delay-Tuple{Expr}","page":"Home","title":"Air.@delay","text":"@delay expression\n\nYields a Delay object that matches the given expression. The expression may be one of the following:\n\nA function of no arguments, such as () -> 10; in this case the delay is made from this function (i.e., the RHS is the -> expression that is delayed).\nA function with a set of symbol arguments evaluates the RHS but uses a let statement to wrap all the symbols in the LHS into a closure.\nAn expression, which is treated as equivalent to () -> expression.\n\nOptionally, the expression or LHS may be tagged with a type T. In this case, a Delay{T} object is yielded instead of a Delay{Any}.\n\nSee also: Delay, LazyDict\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> # Create a Delay with a long run time.\n       d = (@delay (println(\"Running.\"); sleep(2); 10)::Int64)\nDelay{Int64}(<...>)\n\njulia> # Start a few threads, each of which attempt to read it. The function will\n       # only run once.\n       for th in [(Threads.@spawn d[]) for _ in 1:5]; wait(th) end\nRunning.\n\njulia> # Ensure that it produced the correct value and doesn't run again.\n       d[]\n10\n\njulia> # The display now shows the realized value also.\n       d\nDelay{Int64}(10)\n\njulia> # Create a Delay with a locally-bound symbol.\n       d2 = (@delay (d) -> (d[] / 20.0)::Float64)\nDelay{Float64}(<...>)\n\njulia> # We can rebind d without affecting d2.\n       d = 10\n10\n\njulia> d2[]\n0.5\n\n\n\n\n\n","category":"macro"},{"location":"#Air.@memoize-Tuple{Expr}","page":"Home","title":"Air.@memoize","text":"@memoize name(args...) = expr\n@memoize name(args...) where {...} = expr\n\n@memoize is a macro for declaring that the function declaration that follows should be memoized in a private dictionary and any pre-calculated value should be returned from that dictionary instead of being recalculated. All memoization is thread-safe: expr is only ever evaluated by one thread at a time, and is only ever evaluated once per unique set of arguments.\n\nNote that arguments are memoized according to equality, so the use of mutable arguments can result in undefined behavior of those arguments are later changed.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> @memoize fib(n::Int) = begin\n           println(\"Calculating fib($n)...\")\n           if n < 1\n               return 0\n           elseif n == 1\n               return 1\n           else\n               return fib(n-1) + fib(n - 2)\n           end\n       end::Int\nfib (generic function with 1 method)\n\njulia> fib(5)\nCalculating fib(5)...\nCalculating fib(4)...\nCalculating fib(3)...\nCalculating fib(2)...\nCalculating fib(1)...\nCalculating fib(0)...\n5\n\njulia> fib(6)\nCalculating fib(6)...\n8\n\n\n\n\n\n","category":"macro"},{"location":"#Air.@p-Tuple","page":"Home","title":"Air.@p","text":"@p{k1 => v1, k2 => v2, ...}\n@p[x1, x2, ...]\n@p[x1 x2...]\n@p(x1, x2, ...)\n\nYields a persistent data structure, depending on how the macro is called. This is a shorthand for calling the various constructors directly. The following expressions are equivalent:\n\n@p{k1 => v1, k2 => v2, ...} and PDict(k1 => v1, k2 => v2, ...)\n@p[x1, x2, ...] and PVector([x1, x2, ...])\n@p[x1 x2 ...] and PArray([x1 x2 ...])\n@p(x1, x2, ...) and PSet([x1, x2, ...]\n\nSee also: PDict, PVector, PArray, PSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> @p{:a => 1, :b => 2, :c => 3}\nPDict{Symbol,Int64} with 3 entries:\n  :c => 3\n  :a => 1\n  :b => 2\n\njulia> @p[1, 2, 3, 4]\n4-element PArray{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> @p[:q2 :q1; :q3 :q4]\n2×2 PArray{Symbol,2}:\n :q2  :q1\n :q3  :q4\n\njulia> @p(:a, :b, :a, :c)\nPSet{Symbol} with 3 elements:\n  :c\n  :a\n  :b\n\n\n\n\n\n","category":"macro"},{"location":"#Air.@tx-Tuple{Any}","page":"Home","title":"Air.@tx","text":"@tx expr\n\nThe macro @tx should be followed by an expression; that expression is run in an atomic transaction.\n\n\n\n\n\n","category":"macro"},{"location":"#Air.@var-Tuple{Expr}","page":"Home","title":"Air.@var","text":"@var\n\nConvenient syntax for creating a task-local Var object: @var name = initval will construct a Var object with the given initial value. @var name = initval::T will create a Var{T} object.\n\n\n\n\n\n","category":"macro"}]
}
