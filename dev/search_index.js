var documenterSearchIndex = {"docs":
[{"location":"parray/#Persistent-Arrays","page":"Persistent Arrays","title":"Persistent Arrays","text":"","category":"section"},{"location":"parray/","page":"Persistent Arrays","title":"Persistent Arrays","text":"One of the core pieces of Air is the persistent array type. This type is broadly similar to Julia's native array type; the PArray{T,N} type imitates the Array{T,N} type. This page walks through several simple examples of the usage of this type.","category":"page"},{"location":"parray/#Examples","page":"Persistent Arrays","title":"Examples","text":"","category":"section"},{"location":"parray/","page":"Persistent Arrays","title":"Persistent Arrays","text":"julia> using Air\n\n# Persistent arrays are most commonly made from other arrays.\njulia> v = PArray([1.0, 4.4, 2.9])\n3-element PArray{Float64,1}:\n 1.0\n 4.4\n 2.9\n\n# They can also be made using pfill(), pones(), and pzeros(), which are all\n# similar to their non-persistent counterparts fill(), ones(), and zeros().\njulia> m = pfill(5, (2,3))\n2×3 PArray{Int64,2}:\n 5  5  5\n 5  5  5\n\n# The operations push(), pushfirst(), pop(), and popfirst() are all similar to\n# their mutable equivalents (push!(), pushfirst!(), pop!(), and popfirst!()),\n# and all are very efficient with PVector (PArray{*,1}) objects.\njulia> v = push(v, -1.8)\n4-element PArray{Float64,1}:\n  1.0\n  4.4\n  2.9\n -1.8\n\njulia> v = pushfirst(v, -4.3)\n5-element PArray{Float64,1}:\n -4.3\n  1.0\n  4.4\n  2.9\n -1.8\n\njulia> pop(v)\n4-element PArray{Float64,1}:\n -4.3\n  1.0\n  4.4\n  2.9\n  \n# Updates can be performed with setindex(), which is like setindex!().\njulia> setindex(m, -100, 2, 1)\n2×3 PArray{Int64,2}:\n    5  5  5\n -100  5  5","category":"page"},{"location":"pdict/#Persistent-Dictionaries","page":"Persistent Dictionaries","title":"Persistent Dictionaries","text":"","category":"section"},{"location":"pdict/","page":"Persistent Dictionaries","title":"Persistent Dictionaries","text":"One of the core pieces of Air is the persistent dictionary types. These types are broadly similar to Julia's native dictionary types; the PDict{K,V} type imitates the Dict{K,V} type, and the PIdDict{K,V} type imitates IdDict{K,V}. This page walks through several simple examples of the usage of these types.","category":"page"},{"location":"pdict/#Examples","page":"Persistent Dictionaries","title":"Examples","text":"","category":"section"},{"location":"pdict/","page":"Persistent Dictionaries","title":"Persistent Dictionaries","text":"julia> using Air\n\n# Creating a persistent dictionary is just like using Dict().\njulia> cube = PDict{Symbol,Float64}()\nPDict{Symbol,Float64} with 0 entries\n\n# Instead of push!() and setindex!(), PDict objects efficiently produce\n# persistent duplicates of themselves with any requested updates using\n# functions like push() and setindex().\njulia> cube = push(cube, :height => 0.2)\nPDict{Symbol,Float64} with 1 entry:\n  :height => 0.2\n\njulia> cube = push(cube, :width => 9.4, :depth => 1.1)\nPDict{Symbol,Float64} with 3 entries:\n  :depth  => 1.1\n  :height => 0.2\n  :width  => 9.4\n\n# The delete!() function is replaced by delete().\njulia> delete(cube, :height)\nPDict{Symbol,Float64} with 2 entries:\n  :depth => 1.1\n  :width => 9.4\n\n# This does not modify the original object.\njulia> cube\nPDict{Symbol,Float64} with 3 entries:\n  :depth  => 1.1\n  :height => 0.2\n  :width  => 9.4\n\n# Lookup operatoins are nearly as fast as with native Dict objects.\njulia> cube[:height]\n0.2\n\n# The behavioir of PDict is generally similar to Dict.\njulia> cube[:name]\nERROR: KeyError: key :name not found","category":"page"},{"location":"pwset/#Persistent-Weighted-Sets","page":"Persistent Weighted Sets","title":"Persistent Weighted Sets","text":"","category":"section"},{"location":"pwset/","page":"Persistent Weighted Sets","title":"Persistent Weighted Sets","text":"Air supports, in additon to the standard persistent set type PSet, a weighted set PWSet (and PWIdSet). These types are broadly similar to PSet and PIdSet except that their entries additionally have non-negative numeric weights. These sets act as (1) persistent sets, (2) priority queues, and (3) discrete random variables.","category":"page"},{"location":"pwset/#Examples","page":"Persistent Weighted Sets","title":"Examples","text":"","category":"section"},{"location":"pwset/","page":"Persistent Weighted Sets","title":"Persistent Weighted Sets","text":"In progress.","category":"page"},{"location":"pwdict/#Persistent-Weighted-Dictionaries","page":"Persistent Weighted Dictionaries","title":"Persistent Weighted Dictionaries","text":"","category":"section"},{"location":"pwdict/","page":"Persistent Weighted Dictionaries","title":"Persistent Weighted Dictionaries","text":"Air supports, in additon to the standard persistent dictionary type PDict, a weighted dictionary PWDict (and PWIdDict). These types are broadly similar to PDict and PIdDict except that their entries additionally have non-negative numeric weights. These dictoinaries act as (1) dictionaries, (2) priority queues, and (3) discrete random variables.","category":"page"},{"location":"pwdict/#Examples","page":"Persistent Weighted Dictionaries","title":"Examples","text":"","category":"section"},{"location":"pwdict/","page":"Persistent Weighted Dictionaries","title":"Persistent Weighted Dictionaries","text":"In progress.","category":"page"},{"location":"lazydict/#Persistent-Lazy-Dictionaries","page":"Persistent Lazy Dictionaries","title":"Persistent Lazy Dictionaries","text":"","category":"section"},{"location":"lazydict/","page":"Persistent Lazy Dictionaries","title":"Persistent Lazy Dictionaries","text":"One of the core pieces of Air is the persistent dictionary type, PDict. A nearly identical type is the LazyDict. Lazy dictionaries differ from normal persistent dictionaries in that a LazyDict{K,V} may be given a key and values of types K and Delay{V}, respectively, and in this case, only calculates and yields the actual value (of type V) if and when requested. Otherwise, the LazyDict and LazyIdDict types are broadly similar to the PDict and PIdDict types.","category":"page"},{"location":"lazydict/#Examples","page":"Persistent Lazy Dictionaries","title":"Examples","text":"","category":"section"},{"location":"lazydict/","page":"Persistent Lazy Dictionaries","title":"Persistent Lazy Dictionaries","text":"In progress.","category":"page"},{"location":"pset/#Persistent-Sets","page":"Persistent Sets","title":"Persistent Sets","text":"","category":"section"},{"location":"pset/","page":"Persistent Sets","title":"Persistent Sets","text":"The persistent set types are a core feature of Air. These types are broadly similar to Julia's native set types; the PSet{T} type imitates the Set{T} type, and the PIdSet{T} type imitates Core.IdSet{T}. This page walks through several simple examples of the usage of these types.","category":"page"},{"location":"pset/#Examples","page":"Persistent Sets","title":"Examples","text":"","category":"section"},{"location":"pset/","page":"Persistent Sets","title":"Persistent Sets","text":"julia> using Air\n\n# Creating a persistent set is just like using Set().\njulia> names = PSet(:Emily, :Lena, :Stephanie)\nPSet{Symbol} with 3 elements:\n  :Emily\n  :Lena\n  :Stephanie\n\n# Instead of push!(), PSet objects efficiently produce persistent duplicates of\n# themselves with any requested updates using functions like push().\njulia> names = push(names, :Sheri)\nPSet{Symbol} with 4 elements:\n  :Emily\n  :Lena\n  :Stephanie\n  :Sheri\n\njulia> names = push(names, :Caitlin, :Joseph)\nPSet{Symbol} with 6 elements:\n  :Joseph\n  :Emily\n  :Lena\n  :Stephanie\n  :Caitlin\n  :Sheri\n\n# The delete!() function is replaced by delete().\njulia> delete(names, :Emily)\nPSet{Symbol} with 5 elements:\n  :Joseph\n  :Lena\n  :Stephanie\n  :Caitlin\n  :Sheri\n\n# This does not modify the original object.\njulia> names\nPSet{Symbol} with 6 elements:\n  :Joseph\n  :Emily\n  :Lena\n  :Stephanie\n  :Caitlin\n  :Sheri\n\n# Lookup operatoins are nearly as fast as with native Set objects.\njulia> in(:Joseph, names)\ntrue","category":"page"},{"location":"#Air.jl","page":"Home","title":"Air.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An Atomic Immutable Resource for Julia that is as light as air.","category":"page"},{"location":"#Author","page":"Home","title":"Author","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Noah C. Benson &lt;<nben@uw.edu>&gt;","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Air is an immutable data structure and software transactional memory tool for Julia.  It provides several persistent data structures including dictionaries, sets, N-dimensional arrays, heaps, weighted dictionaries, and weighted sets, and it includes a transaction system that allows one to compose atomic operations over such data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Air is currently under development but includes substantial testing and is generally stable.  Inspiration for Air's design is derived largely from paradigms in Clojure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The full API reference for Air can be found here.","category":"page"},{"location":"API/#The-Full-Air-API-Reference","page":"The Full Air API Reference","title":"The Full Air API Reference","text":"","category":"section"},{"location":"API/#Index","page":"The Full Air API Reference","title":"Index","text":"","category":"section"},{"location":"API/","page":"The Full Air API Reference","title":"The Full Air API Reference","text":"Modules = [Air]","category":"page"},{"location":"API/#API-Documents","page":"The Full Air API Reference","title":"API Documents","text":"","category":"section"},{"location":"API/","page":"The Full Air API Reference","title":"The Full Air API Reference","text":"Modules = [Air]","category":"page"},{"location":"API/#Air.TX_MAX_ATTEMPTS","page":"The Full Air API Reference","title":"Air.TX_MAX_ATTEMPTS","text":"TX_MAX_ATTEMPTS\n\nThe maximum number of retry attempts that a transaction will make before aborting the transaction.\n\n\n\n\n\n","category":"constant"},{"location":"API/#Air.airout","page":"The Full Air API Reference","title":"Air.airout","text":"airout\n\nThe airout object is a AirOut object that wraps the stdout object.\n\nSee also: AirOut\n\n\n\n\n\n","category":"constant"},{"location":"API/#Air.current_tx","page":"The Full Air API Reference","title":"Air.current_tx","text":"current_tx\n\nThe current_tx constant is a Var{T} that stores the current task's running Transaction, or nothing if there is no transaction running.\n\nSee also: currtx\n\n\n\n\n\n","category":"constant"},{"location":"API/#Air.AbstractPArray","page":"The Full Air API Reference","title":"Air.AbstractPArray","text":"AbstractPArray{T,N}\n\nThe Abstract persistent array type represents any Array-like type that is persistent. The Air library provides the reified type PArray{T,N}.\n\nSee also: PArray, PVector.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.AbstractPDict","page":"The Full Air API Reference","title":"Air.AbstractPDict","text":"AbstractPDict{K,V}\n\nAbstractPDict is a subtype of AbstractDict that is extended only by persistent dictionary types such as PDict and LazyDict.\n\nSee also PDict, PWDict, LazyDict, PIdDict, LazyIdDict, PWIdDict.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.AbstractPSet","page":"The Full Air API Reference","title":"Air.AbstractPSet","text":"AbstractPSet{T}\n\nAbstractPSet is an abstract type extended by persistent set types such as  PSet and `PWSet.\n\nSee also: PSet, PIdSet, PWSet, PWIdSet.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.AbstractPWDict","page":"The Full Air API Reference","title":"Air.AbstractPWDict","text":"AbstractPWDict\n\nAbstractPWDict is a subtype of AbstractPDict that is overloaded by classes that represent weighted persistent dictionaries.\n\nSee also: AbstractPDict, PWDict, AbstractPWSet.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.AbstractPWSet","page":"The Full Air API Reference","title":"Air.AbstractPWSet","text":"AbstractPWSet{T,W}\n\nAbstractPWSet is an abstract type implemented by all persistent weighted set types.\n\nSee also: PWSet, AbstractPSet.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.Actor","page":"The Full Air API Reference","title":"Air.Actor","text":"Actor{T}\n\nAn actor is an object that represents a worker-thread to which tasks can be scheduled. Any scheduled function is guaranteed to be evaluated at some point in the future in some other thread, and the return value of that function will become the new value held by the actor. Each function, when it is run, is passed the actor's value as one of its argument.\n\nLike with Refs, you can access an actor's current value using getindex,  e.g., actor[]. Within a transaction, this will be guaranteed to remain fixed for the duration of the transaction; outside of a transaction, this may change at arbitrary times.\n\nActors may be initialized with post-processing functions. These functions are called immediately after executing any scheduled function and are given as their first argument the original actor value and as their second argument the return value of the scheduled function. Instead of saving this return value, the return value of the post-processing function is saved in the actor. This is useful for actors whose job is, for example, to serialize output to a log file being written to across many threads. If we run something like  send(println, log_actor, \"Some log message\") the println function will return nothing, which we would like to convert back into the log stream so that subsequent send calls can continue to use the println fuction.\n\nActors may additionally be given an error handler. Whenever an exception occurs during a scheduled function, the error handler will be called with the arguments of (1) the actor object, (2) the current actor value, and (3) the exception that was caught. When an error has occurred, any attempt to schedule a function to the actor or to read from the actor will cause an exception to be raised. The error may be examined using geterror(actor) and restarted using reset(actor).\n\nAll fields in an actor object should be considered strictly private. These fields are likely to change between releases, and changing the values will break your code.\n\nSee also: tx, @tx, send, geterror, reset.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> a = Actor{Symbol}(:start_sym)\nActor{Symbol}(@JIm7aUS2sOl: :start_sym)\n\njulia> send(a) do val; sleep(0.1); Symbol(\"new_$(val)\") end\nActor{Symbol}(@JIm7aUS2sOl: :start_sym)\n\njulia> sleep(1); a[]\n:new_start_sym\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.ActorException","page":"The Full Air API Reference","title":"Air.ActorException","text":"ActorException{T}(error, value, argno, args)\n\nAn ActorException object is thrown whenever one attempts to obtain the value of or send a function to an actor that is in an error state. An error state occurs when an unhandled exception is raised while an actor is processing a sent function. In such a case the geterror() and restart() functions may be used. The geterror() function yields an ActorException object in which the exception that was raised is stored as error, the value of the actor when the send was run is stored in value, and the args and argno give the full contex of the send call (i.e., the fucntion followed by the arguments is args and the argument number that corresponds to the actor is argno).\n\nSee also: Actor, geterror, reset, send\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.ActorMsg","page":"The Full Air API Reference","title":"Air.ActorMsg","text":"ActorMsg\n\nA message, queued for an Actor via the send() function.\n\nThe ActorMsg struct is considered part of Air's private/internal implementation details.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.ActorTxData","page":"The Full Air API Reference","title":"Air.ActorTxData","text":"ActorTxData{T}\n\nThe data tracked for an Actor{T} during a transaction by the transaction's  Transaction struct.\n\nThe ActorTxData struct is considered part of the internal/private code of Air and generally should not be used outside of the Air library.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.AirOut","page":"The Full Air API Reference","title":"Air.AirOut","text":"AirOut\n\nThe AirOut type is a derivative of the IO class and is intended for handling output to stdout across multiple threads in a thread-safe way. It is similar TxIO except that it only writes to stdout and is only really intended for use with the airout object.\n\nSee also: Actor, airout, TxIO\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.Delay","page":"The Full Air API Reference","title":"Air.Delay","text":"Delay{T}\n\nDelay objects can be used to lazily calculate a single value the first time it is requested. They act like Refs in that you access a delay d via d[]. Delay objects are thread-safe and are functionally immutable.\n\nSee also: @delay, LazyDict\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> # Create a Delay with a long run time.\n       d = Delay{Int64}(() -> (println(\"Running.\"); sleep(2); 10))\nDelay{Int64}(<...>)\n\njulia> # Start a few threads, each of which attempt to read it. The function\n       # will only run once.\n       for th in [(Threads.@spawn d[]) for _ in 1:5]; wait(th) end\nRunning.\n\njulia> # Ensure that it produced the correct value and doesn't run again.\n       d[]\n10\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.LazyDict","page":"The Full Air API Reference","title":"Air.LazyDict","text":"LazyDict{K,V}\n\nA dictionay type equivalent to PDict{K,V} in every way except that for any value in the dict that is a Delay object, the dictionary hides the delay and always returns the delay's value. This allows any value that has not yet been requested to be lazily unevaluated.\n\nSee also: PDict, Base.Dict, LazyIdDict, Delay, @delay.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> LazyDict()\nLazyDict{Any,Any}()\n\njulia> LazyDict(:a => 1, :b => 2, :c => 12.8)\nLazyDict{Symbol,Real} with 3 entries:\n  :c => 12.8\n  :a => 1\n  :b => 2\n\njulia> d = LazyDict{Symbol,Float64}(:a => 1, :b => 2, :c => 12.8)\nLazyDict{Symbol,Float64} with 3 entries:\n  :c => 12.8\n  :a => 1.0\n  :b => 2.0\n\njulia> d2 = push(d, :d => Delay{Real}(() -> (println(\"Running...\"); 0.5))); haskey(d2, :d)\ntrue\n\njulia> d2[:d]\nRunning...\n0.5\n\njulia> d2[:d]\n0.5\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.LazyIdDict","page":"The Full Air API Reference","title":"Air.LazyIdDict","text":"LazyIdDict{K,V}\n\nA dictionay type equivalent to PIdDict{K,V} in every way except that for any value in the dict that is a Delay object, the dictionary hides the delay and always returns the delay's value. This allows any value that has not yet been requested to be lazily unevaluated.\n\nSee also: PIdDict, Base.IdDict, LazyDict, Delay, @delay.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> LazyIdDict()\nLazyIdDict{Any,Any}()\n\njulia> LazyIdDict(:a => 1, :b => 2, :c => 12.8)\nLazyIdDict{Symbol,Real} with 3 entries:\n  :b => 2\n  :a => 1\n  :c => 12.8\n\njulia> d = LazyIdDict{Symbol,Float64}(:a => 1, :b => 2, :c => 12.8)\nLazyIdDict{Symbol,Float64} with 3 entries:\n  :b => 2.0\n  :a => 1.0\n  :c => 12.8\n\njulia> d2 = push(d, :d => Delay{Real}(() -> (println(\"Running...\"); 0.5)));\n\njulia> haskey(d2, :d)\ntrue\n\njulia> d2[:d]\nRunning...\n0.5\n\njulia> d2[:d]\n0.5\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PArray","page":"The Full Air API Reference","title":"Air.PArray","text":"PArray{T,N}\n\nThe PArray type is a persistent/immutable corrolary to the Array{T,N} type. Like Array, PArray can store n-dimensional non-ragged arrays. However, unlike Arrays, PArrays can create duplicates of themselves with finite edits in log-time.\n\nPArrays have a similar interface as Arrays, but instead of the functions push!, pop!, and setindex!, PArrays use push, pop, and setindex. PArrays also have efficient implementations of pushfirst and popfirst.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PArray()\n0-element PArray{Any,1}\n\njulia> u = PArray{Int,1}([1,2])\n2-element PArray{Int64,1}:\n 1\n 2\n\njulia> push(u, 3)\n3-element PArray{Int64,1}:\n 1\n 2\n 3\n\njulia> PArray{Symbol,2}(:abc, (2,3))\n2×3 PArray{Symbol,2}:\n :abc  :abc  :abc\n :abc  :abc  :abc\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PDict","page":"The Full Air API Reference","title":"Air.PDict","text":"PDict{K,V}\n\nA dictionay type roughly equivalent to Dict{K,V} but that stores data using a persistent hash array mapped trie system that allows for efficient persistent operations. These operations are represented by non-mutating versions of the standard dictionary functions, such as setindex in place of setindex!, push in place of push!, and pop in place of pop!. These operations are performed in O(log n) time, and minimal data duplication is performed in  update operations.\n\nSee also: PIdDict, Dict, push, pop, setindex, delete, insert, getpair.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PDict()\nPDict{Any,Any}()\n\njulia> PDict(:a => 1, :b => 2, :c => 12.8)\nPDict{Symbol,Real} with 3 entries:\n  :c => 12.8\n  :a => 1\n  :b => 2\n\njulia> d = PDict{Symbol,Float64}(:a => 1, :b => 2, :c => 12.8)\nPDict{Symbol,Float64} with 3 entries:\n  :c => 12.8\n  :a => 1.0\n  :b => 2.0\n\njulia> :b in keys(d)\ntrue\n\njulia> d[:c]\n12.8\n\njulia> push(d, :d => 0.1)\nPDict{Symbol,Float64} with 4 entries:\n  :d => 0.1\n  :c => 12.8\n  :a => 1.0\n  :b => 2.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PHeap","page":"The Full Air API Reference","title":"Air.PHeap","text":"PHeap{T,W,F}\n\nA PHeap object is a priority queue to which objects can be pushed and given a particular weight. PHeaps can then be iterated in weighted order, popped in weighted order, and the first  element may be obtained in weighted order. Additionally, a random sample may be drawn from a heap, which uses the distribution implied by the relative weights of the items in the heap.\n\nPHeap objects may be initialized with a single argument of type F <: Function, in which case this function is used to compare the weights for ordering. By default this is > such that high weights are retrieved first by the first() function and removed first by the pop() function. Note, however, that the relative weights are still used by the rand function regardless of the ordering function, so negative values cannot be used.\n\nSee also: PWSet, PWDict, pop, Base.first.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PIdDict","page":"The Full Air API Reference","title":"Air.PIdDict","text":"PIdDict{K,V}\n\nA dictionay type roughly equivalent to IdDict{K,V} but that stores data using a persistent hash array mapped trie system that allows for efficient persistent operations. These operations are represented by non-mutating versions of the standard dictionary functions, such as setindex in place of setindex!, push in place of push!, and pop in place of pop!. These operations are performed in O(log n) time, and minimal data duplication is performed in  update operations.\n\nSee also: PDict, Base.IdDict, push, pop, setindex, delete, insert, getpair.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PIdDict()\nPIdDict{Any,Any}()\n\n\njldoctest; filter=r\"PIdDict{Symbol, ?Real} with 3 entries:\" julia> PIdDict(:a => 1, :b => 2, :c => 12.8) PIdDict{Symbol,Real} with 3 entries:   :c => 12.8   :a => 1   :b => 2\n\n\n\njldoctest; filter=r\"PIdDict{Symbol, ?Float64} with [34] entries:\" julia> d = PIdDict{Symbol,Float64}(:a => 1, :b => 2, :c => 12.8) PIdDict{Symbol,Float64} with 3 entries:   :c => 12.8   :a => 1.0   :b => 2.0\n\njulia> :b in keys(d) true\n\njulia> d[:c] 12.8\n\njulia> push(d, :d => 0.1) PIdDict{Symbol,Float64} with 4 entries:   :d => 0.1   :c => 12.8   :a => 1.0   :b => 2.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PIdLinearDict","page":"The Full Air API Reference","title":"Air.PIdLinearDict","text":"PIdLinearDict{K,V}\n\nAn identity-based persistent dict type that uses a simple array representation internally; accordingly PIdLinearDict does not peform persistent operations such as setindex, push, and delete efficiently. It is intended to be used by Air internally as a sub-dict that stores items whose hash values are identical.\n\nSee also: PLinearDict, PIdDict.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PIdLinearSet","page":"The Full Air API Reference","title":"Air.PIdLinearSet","text":"PIdLinearSet{T}\n\nA persistent IdSet type that uses a simple array representation internally; accordingly PIdLinearSet does not peform persistent operations such as setindex, push, and delete efficiently. It is intended to be used by Air internally as a set that stores items whose hash values are identical.\n\nSee also: PLinearSet, PSet.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PIdSet","page":"The Full Air API Reference","title":"Air.PIdSet","text":"PIdSet{T}\n\nA persistent identity-based set type that uses an array hash-mapped trie structure to allow for efficient updating of the set using the persistent operations defined by Air such as push, and delete.\n\nSee also: Set, PIdSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PIdSet()\nPIdSet{Any}()\n\njulia> :a in PIdSet([:a, :b, :c])\ntrue\n\njulia> :d in PIdSet([:a, :b, :c])\nfalse\n\njulia> :d in push(PIdSet(), :d)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PLinearDict","page":"The Full Air API Reference","title":"Air.PLinearDict","text":"PLinearDict{K,V}\n\nA persistent dict type that uses a simple array representation internally; accordingly PLinearDict does not peform persistent operations such as setindex, push, and delete efficiently. It is intended to be used by Air internally as a sub-dict that stores items whose hash values are identical.\n\nSee also: PIdLinearDict, PDict.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PLinearSet","page":"The Full Air API Reference","title":"Air.PLinearSet","text":"PLinearSet{T}\n\nA persistent set type that uses a simple array representation internally; accordingly PLinearSet does not peform persistent operations such as setindex, push, and delete efficiently. It is intended to be used by Air internally as a set that stores items whose hash values are identical.\n\nSee also: PIdLinearSet, PSet.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PMatrix","page":"The Full Air API Reference","title":"Air.PMatrix","text":"PMatrix{T}\n\nAn alias for PArray{T,2}, representing a persistent matrix.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PSet","page":"The Full Air API Reference","title":"Air.PSet","text":"PSet{T}\n\nA persistent set type that uses an array hash-mapped trie structure to allow for efficient updating of the set using the persistent operations defined by Air such as setindex, push, and delete.\n\nSee also: Set, PIdSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PSet()\nPSet{Any}()\n\njulia> :a in PSet([:a, :b, :c])\ntrue\n\njulia> :d in PSet([:a, :b, :c])\nfalse\n\njulia> :d in push(PSet(), :d)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PTree","page":"The Full Air API Reference","title":"Air.PTree","text":"PTree{T}\n\nPTree is a persistent tree/array hybrid that maps arbitrary unsigned integers (type HASH_T) to values. It can efficiently be used for arrays or for hash-maps, and supports efficient lookup, association, and dissociation.\n\nAll fields of a PTree should be considered strictly private, as modification of the fields may result in a kernel crash. The properties of a PTree are both immutable and safe to inpect.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PVector","page":"The Full Air API Reference","title":"Air.PVector","text":"PVector{T}\n\nAn alias for PArray{T,1}, representing a persistent vector.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PWDict","page":"The Full Air API Reference","title":"Air.PWDict","text":"PWDict{K,V}\n\nA persistent dictionary with weighted pairs. As such, a PWDict supports the typical operations of a PDict as well as the following:\n\nThe first function yields the key-value pair with the highest weight.\nThe pop function yields a copy of the dictionary without the pair that has the highest weight.\nIteration occurs in the order of greatest to least weight.\nThe weights can be changed with the getweight and setweight functions; setweight yields a duplicate dictionary with updated weights.\n\nSee also: PDict, getweight, setweight.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PWDict{Symbol,Int}(:a => (1,0.1), :b => (2, 0.2), :c => (3, 0.3))\nPWDict{Symbol,Int64,Float64} with 3 entries:\n  :c => 3\n  :b => 2\n  :a => 1\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PWIdDict","page":"The Full Air API Reference","title":"Air.PWIdDict","text":"PWIdDict{K,V}\n\nA persistent dictionary with weighted pairs. As such, a PWIdDict supports the typical operations of a PIdDict as well as the following:\n\nThe first function yields the key-value pair with the highest weight.\nThe pop function yields a copy of the dictionary without the pair that has the highest weight.\nIteration occurs in the order of greatest to least weight.\nThe weights can be changed with the getweight and setweight functions; setweight yields a duplicate dictionary with updated weights.\n\nSee also: PIdDict, PWDict, getweight, setweight.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PWIdDict{Symbol,Int}(:a => (1,0.1), :b => (2, 0.2), :c => (3, 0.3))\nPWIdDict{Symbol,Int64,Float64} with 3 entries:\n  :c => 3\n  :b => 2\n  :a => 1\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PWIdSet","page":"The Full Air API Reference","title":"Air.PWIdSet","text":"PWIdSet{T}\n\nA persistent set with weighted elements. As such, a PWIdSet supports the typical operations of a PIdSet as well as the following:\n\nThe first function yields the element with the highest weight.\nThe pop function yields a copy of the set without the element that has the highest weight.\nIteration occurs in the order of greatest to least weight.\nThe weights can be changed with the getweight and setweight functions; setweight yields a duplicate dictionary with updated weights.\n\nSee also: PIdSet, PWSet, getweight, setweight.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PWIdSet{Symbol}(:a => 0.1, :b => 0.2, :c => 0.3)\nPWIdSet{Symbol,Float64} with 3 elements:\n  :c\n  :b\n  :a\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.PWSet","page":"The Full Air API Reference","title":"Air.PWSet","text":"PWSet{K,V}\n\nA persistent set with weighted elements. As such, a PWSet supports the typical operations of a PSet as well as the following:\n\nThe first function yields the element with the highest weight.\nThe pop function yields a copy of the set without the element that has the highest weight.\nIteration occurs in the order of greatest to least weight.\nThe weights can be changed with the getweight and setweight functions; setweight yields a duplicate dictionary with updated weights.\n\nSee also: PSet, getweight, setweight.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> PWSet{Symbol}(:a => 0.1, :b => 0.2, :c => 0.3)\nPWSet{Symbol,Float64} with 3 elements:\n  :c\n  :b\n  :a\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.Promise","page":"The Full Air API Reference","title":"Air.Promise","text":"Promise{T}\n\nPromise objects represent placeholders for values that may or may not have been delivered yet. This is effectively a Channel object that can only be put! to a single time and all take calls on the promise will return that value. Promise values can be accessed via the take() function (not the take!() function) or via p[] for promise p. In both cases, the running thread is suspended until a value is delivered.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> p = Promise{Symbol}()\nPromise{Symbol}(<...>)\n\njulia> isready(p)\nfalse\n\njulia> put!(p, :value)\n:value\n\njulia> isready(p)\ntrue\n\njulia> take(p)\n:value\n\njulia> p[]\n:value\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.ReentrantRef","page":"The Full Air API Reference","title":"Air.ReentrantRef","text":"ReentrantRef{T}\n\nA ReentrantRef is a type of ref object that is thread-safe. There are a few strategies for this, each of which are encoded in a different object type that inheits from ReentrantRef. These types are as follows.\n\nVar: Var objects act like Ref objects except that changes to them are exclusively task-local and must be performed in specific scoped expressions. However, the state of all Var objects for the current task can also be saved and restored at a later point.\n\nActor: Actor objects obey the actor pattern; you can call send(fn, actor, args...) where fn is a function that is, in another thread at some point, called as fn(actor[], args...). The new value of the actor after running fn is the return value of the call.\n\nVolatile: Volatile objects are Refs that can be changed by any thread but that must be changed only within a synchronized transaction that ensures that all reads and writes of volatiles, as well as reads from and sends to actors, are atomic: either they all happen successfully, or none of them do.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.Transaction","page":"The Full Air API Reference","title":"Air.Transaction","text":"Transaction\n\nA transaction object keeps track of what is going on during a particular transaction. These are generally low-level objects that shouldn't be touched directly.\n\nTransactions have the following propertiies:\n\nstate is either :running, :validating, or :error;\nrvolatiles is the set of all Volatile objects that have been read during the transaction;\nwvolatiles is the set of all Volatile objects that have been changed;\nactors is the set of all Actor objects to which messagees have been sent during the transaction; and\nsources is the set of all Source objects from which items have been popped.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.TransactionalRef","page":"The Full Air API Reference","title":"Air.TransactionalRef","text":"TransactionalRef{T}\n\nA TransactionalRef is a reentrant reference that additional participates in transactions. Transactional refs include Actors and Volatiles.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.TxIO","page":"The Full Air API Reference","title":"Air.TxIO","text":"TxIO\n\nThe TxIO type is a derivative of the IO class and is intended for handling output to streams across multiple threads in a thread-safe way. TxIO objects can be constructed from IO objects and can be printed/written to like normal IO objects. However, all output is performed in a separate asynchronous thread, and writes that occur during a transaction always occur only if the transaction succeeds.\n\nSee also: Actor, airout\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.TxRetryException","page":"The Full Air API Reference","title":"Air.TxRetryException","text":"TxRetryException\n\nA TxRetryException is throws when a transaction needs to be retried but an error hasn't necessarily been generated otherwise. This can be thrown during a transaction to restart the transaction; though doing this can easily lead to infinite loops.\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.Var","page":"The Full Air API Reference","title":"Air.Var","text":"Var{T}\n\nA Var object represents a task-local piece of data with a default value. You can access a Var with the getindex function (var[]) and you can set it with the setindex! function (var[] = newval). However, the new assignment will always be task-local only. Because of this, Vars are safe to access and update in a multi-threaded program.\n\nAll fields of a Var should be considered strictly private.\n\nSee also: @var, ReentrantRef, vars, withvars, wrapsetvars, wrapwithvars,  Threads.current_task, Threads.task_local_storage.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> v = Var{Symbol}(:start_sym)\nVar{Symbol}(@JIm7aUS2sOl: :start_sym; init=:start_sym)\n\njulia> v[]\n:start_sym\n\njulia> withvars(v => :new_sym) do; v[] end\n:new_sym\n\njulia> withvars(v => :new_sym) do; fetch(Threads.@spawn v[]) end\n:start_sym\n\njulia> v[]\n:start_sym\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.VarsDict","page":"The Full Air API Reference","title":"Air.VarsDict","text":"VarsDict\n\nThe type of a dictionary of Var bindings, as returned by the function vars() and as is required by the function setvars().\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.Volatile","page":"The Full Air API Reference","title":"Air.Volatile","text":"Volatile{T}(value)\nVolatile{T}(value, filter_fn)\nVolatile{T}(value, filter_fn, finalize_fn)\n\nVolatile objects are Ref objects that must be used in conjunction with transaction blocks (see @tx and tx). The value of a Volatile can be accessed at any time, and there is no particular guarantee that a Volatile's value won't be changed by another thread outside of a transaction, thus reading them outside of a transaction can potentially create race conditions. Critically, Volatile objects can only be set inside of a transaction, and, within a transaction, a Volatile's value is guaranteed to be constant. In other words, Volatile objects are Ref objects that behave as if they are locked for the executing thread whenever that thread is inside a transaction block.\n\nThe arguments filter_fn and finnalize_fn are functions for making sure that the value of a volatile conforms to some standard. The two functions are similar but are intended for slightly different use cases:\n\nfilter_fn is called every time the value of a volatile is set. The value saved in the volatile is filter_fn(value) instead of value itself. Values are only filtered when the volatile is set directly (vol[] = value)–-the filter is not rerun when the filter_fn is changed (via setfilter!) nor when the finalize_fn returns a value.\nfinalize_fn is called with the volatile's value immediately after the body of the transaction has completed, but before a commit is attempted. The finalize_fn function acts like the filter_fn in that finalize_fn(value) replaces value in the volatile.\n\nBoth filter_fn and finalize_fn can throw exceptions, which will abort the running transaction.\n\nFor a Volatile v, one may set v's stored value via v[] = value. This must be done inside a transaction (via tx or @tx). To change the filter or the finalize functions, use the setfilter! and setfinalize! functions, both of which also must be run in transactions as well.\n\nSee also: tx, @tx, setfilter!, setfinalize!.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> v = Volatile{Symbol}(:startval)\nVolatile{Symbol}(@JIm7aUS2sOl: :startval)\n\njulia> @tx v[] = :newval\n:newval\n\njulia> v[]\n:newval\n\n\n\n\n\n","category":"type"},{"location":"API/#Air.actor_main-Union{Tuple{Actor{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.actor_main","text":"actor_main(actor)\n\nThe actor main function is what actually manages everything behind the scenes in the actor tasks. Note that this function and the task/thread it is running in is the only place that the actor's value can be legally changed. Changing the value anywhere else can result in undefined behavior. The actor's condition should never change.\n\nThis function is designed to process all the messages in an actor's queue then to return. When a new thread wants to enqueue a message to an actor that has an empty queue, that thread must spin up the actor_main function to process the items in the queue (this is done by the send function automatically).\n\nThis function is part of Air's internal/private implementation details.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.actor_reset!-Union{Tuple{T}, Tuple{Actor{T}, Any}} where T","page":"The Full Air API Reference","title":"Air.actor_reset!","text":"actor_reset!(actor, val)\n\nResets the given actor to have the given value. If the actor is not in an error state, yields nothing and does nothing. Otherwise, yields the ActorExcption object that was cleared. It is required that the actor's mutex be held at ths time this function is called.\n\nThis function is considered part of Air's internal/private implementation details.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.actor_reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}","page":"The Full Air API Reference","title":"Air.actor_reset","text":"actor_reset(a, s)\n\nIf the given Actor object a is in an error state, this function resets the actor to have the new value s then yields the ActorException object that was just cleared. If a is not in an error state, this function simply yields nothing.\n\nThis function is considered part of the internal/private interface of Air and shouldn't generally be called outside of it.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.actor_send!-Union{Tuple{T}, Tuple{Actor{T}, Air.ActorMsg}} where T","page":"The Full Air API Reference","title":"Air.actor_send!","text":"actor_send!(actor, message)\n\nEnqueues the given message to the given actor and starts the actor's task, if necessary. This function requires that the actor's condition be held. Yields the actor.\n\nThis function is considered part of Air's internal/private implementation details.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.actor_send-Union{Tuple{T}, Tuple{Actor{T}, Air.ActorMsg}} where T","page":"The Full Air API Reference","title":"Air.actor_send","text":"actor_send(a, msg)\n\nAdds the given ActorMsg message object msg to the queue of the given Actor object a such that it will be processed in a separate thread. Yields nothing.\n\nThis function is considered part of the internal/private interface of Air and shouldn't generally be called outside of it.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.actor_start!-Union{Tuple{Actor{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.actor_start!","text":"actor_start!(actor)\n\nIf the given Actor object is not in an error state, is not running, and does not have an empty queue, then actor_start!(actor) will start actor's processing task. This should only be called by send! when the first message to an empty queue is finalized.\n\nIf either the actor is already running or the task is successfully started, then that task is yielded. If the actor has an empty queue, then nothing is returned, and if the actor is in an error state, then an exception is thrown.\n\nNote: It is required that the mutx for the given actor be held when this function is called; otherwise race conditions could be inadvertantely created. The actor_start method locks the actor's mutex then calls this function. Both methods are private to Air and should not generally be used outside of it.\n\nThis function is considered part of Air's internal/private implementation details.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.actor_start-Union{Tuple{Actor{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.actor_start","text":"actor_start(actor)\n\nIf the given Actor object is not in an error state, is not running, and does not have an empty queue, actor_start(actor) will start actor's processing task. This should only be called by send! when the first message to an empty queue is finalized.\n\nIf either the actor is already running or the task is successfully started, then that task is yielded. If the actor has an empty queue, then nothing is returned, and if the actor is in an error state, then an exception is thrown.\n\nThis function is considered part of Air's internal/private implementation details.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.actor_value-Union{Tuple{Actor{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.actor_value","text":"actor_value(a)\n\nYields the in-transaction value for the given Actor object a if there is a running transaction; otherwise yields the current out-of-transaction value of a.\n\nThis function is considered part of the internal/private interface of Air and shouldn't generally be called outside of it.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.currtx-Tuple{}","page":"The Full Air API Reference","title":"Air.currtx","text":"currtx()\n\nYields the current Transaction object, or nothing if there is no transaction running in the current task.\n\nSee also: Transaction\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> currtx() === nothing\ntrue\n\njulia> @tx (currtx() === nothing)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}","page":"The Full Air API Reference","title":"Air.delete","text":"delete(coll, k)\n\nYields a copy of the collection coll with the item associated with the given index or key k deleted. This function works on dictionaries, vectors, tuples, and sets, and it always yields a copy of the collection without modifying its aguments. For the persistent collections defined in Air, this is efficient, but for most mutable objects, this is O(n).\n\nSee also: Base.delete!, insert, pop.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> delete((:a,:b,:c,:d), 2)\n(:a, :c, :d)\n\njulia> u = [:a,:b,:c,:d]; delete(u, 1)\n3-element Array{Symbol,1}:\n :b\n :c\n :d\n\njulia> s1 = Set([:a,:b,:c,:d]); s2 = delete(s1, :d); (:d in s1, :d in s2)\n(true, false)\n\njulia> b = BitArray([0,0,0,1,0]); delete(b, 4)\n4-element BitArray{1}:\n 0\n 0\n 0\n 0\n\njulia> b[2]\nfalse\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.depth_to_bitshift-Tuple{Integer}","page":"The Full Air API Reference","title":"Air.depth_to_bitshift","text":"depth_to_bitshift(depth)\n\nYields the tuple (B0,S) of the first bit index and the shift for the given depth.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.equalfn-Tuple{T} where T","page":"The Full Air API Reference","title":"Air.equalfn","text":"equalfn(x)\n\nIf x is an object (such as a PSet or Dict) that has an opinion about equality, equalfn(x) returns the function that it uses.\n\nSee also: hashfn\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> equalfn(Dict) == isequal\ntrue\n\njulia> equalfn(IdDict) == (===)\ntrue\n\njulia> equalfn(PSet) == isequal\ntrue\n\njulia> equalfn(PArray)\nERROR: ArgumentError: no equalfn for type PArray\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.geterror","text":"geterror(actor)\n\nIf the given Actor object is currently in an error state, then yields the ActorException object that describes the error. Otherwise, yields nothing.\n\nSee also: Actor, reset, send\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> a = Actor{Symbol}(:start_sym)\nActor{Symbol}(@JIm7aUS2sOl: :start_sym)\n\njulia> geterror(a) === nothing\ntrue\n\njulia> send(a) do val; error(\"test\") end\nActor{Symbol}(@JIm7aUS2sOl: :start_sym)\n\njulia> sleep(1); a\nActor{Symbol}(@JIm7aUS2sOl: --error--)\n\njulia> geterror(a) isa ActorException\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.getfilter-Union{Tuple{Volatile{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.getfilter","text":"getfilter(v)\n\nYields the filter-function for the volatile v.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.getfinalize-Union{Tuple{Volatile{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.getfinalize","text":"getfinalize(v)\n\nYields the finalize-function for the volatile v.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.getpair","page":"The Full Air API Reference","title":"Air.getpair","text":"getpair(d, k)\n\nIf the key k is found in the dictionary d, yields the pair (k => d[k]); otherwise yields missing.\n\nSee also: Base.get, Base.getindex.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> d = Dict(:a => 1, :b => 2, :c => 3); getpair(d, :a)\n:a => 1\n\njulia> getpair(d, :x)\nmissing\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S}} where {T, W, F, D, S}","page":"The Full Air API Reference","title":"Air.getweight","text":"getweight(h, x)\n\nYields the weight for the given value x in the given persistent heap or persistent weighted collection h. If h is a weighted dictionary, then x should be the key.\n\nIf the key or object x is not found in the collection h, then 0 is returned.\n\nSee also: setweight, PWDict, PWSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> d = PWSet{Symbol}(:a => 1.0, :b => 2.0, :c => 3.0)\nPWSet{Symbol,Float64} with 3 elements:\n  :c\n  :b\n  :a\n\njulia> getweight(d, :a)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.hashfn-Tuple{T} where T","page":"The Full Air API Reference","title":"Air.hashfn","text":"hashfn(x)\n\nIf x is an object (such as a PSet or Dict) that has an opinion about how it hashes objects, hashfn(x) returns the function that it uses. It is sufficient in almost all circumstances to define equalfn(T); the hashfn should always match the equalfn regardless.\n\nSee also: equalfn\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> hashfn(Dict) == hash\ntrue\n\njulia> hashfn(IdDict) == objectid\ntrue\n\njulia> hashfn(PSet) == hash\ntrue\n\njulia> hashfn(PArray)\nERROR: ArgumentError: no equalfn for type PArray\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.highmask-Union{Tuple{K}, Tuple{T}, Tuple{K, Type{T}}} where {T<:Unsigned, K<:Integer}","page":"The Full Air API Reference","title":"Air.highmask","text":"highmask(bitno, T)\nhighmask(bitno)\n\nYields a mask of (unsigned integer) type T with all bits above the given bit number set to true and all bits below that number set to false. The bit itself is set to true. Bits are indexed starting at 0.\n\nThe default value of T is the PTree hash type (HASH_T).\n\nhighmask(bitno) is equal to ~lowmask(bitno).\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.insert","page":"The Full Air API Reference","title":"Air.insert","text":"insert(coll, idx, val)\n\nYields a copy of the given collection coll with the given value cal inserted at the given index. Roughly equivalent to insert!(copy(arr), idx, va): the insert function never modifies its arguments and always yields a copy. For the persistent collections defined in Air, this operation is efficient, but for most mutable objects, this is O(n).\n\nSee also: Base.insert!, push, delete.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> insert((:a,:b,:c,:d), 2, :x)\n(:a, :x, :b, :c, :d)\n\njulia> u = [:a,:b,:c,:d]; insert(u, 1, :x)\n5-element Array{Symbol,1}:\n :x\n :a\n :b\n :c\n :d\n\njulia> length(u)\n4\n\njulia> b = BitArray([0,0,0,0]); insert(b, 2, 1)\n5-element BitArray{1}:\n 0\n 1\n 0\n 0\n 0\n\njulia> b[2]\nfalse\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.lockall","page":"The Full Air API Reference","title":"Air.lockall","text":"lockall(f, l1, l2, ...)\n\nLocks all of the lockable objects l1, l2, etc. then runs f, unlocks the objects, and returns the return value of f().\n\nSee also: Threads.ReentrantLock\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> (r1, r2, r3) = [ReentrantLock() for _ in 1:3]\n       lockall(r1, r2, r3) do; :success end\n:success\n\njulia> lockall([r1, r2, r3]) do; :success end\n:success\n\njulia> lockall((r1, r2, r3)) do; :success end\n:success\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.lowmask-Union{Tuple{K}, Tuple{T}, Tuple{K, Type{T}}} where {T<:Unsigned, K<:Integer}","page":"The Full Air API Reference","title":"Air.lowmask","text":"lowmask(bitno, T)\nlowmask(bitno)\n\nYields a mask of (unsigned integer) type T with all bits above the given bit number set to false and all bits below that number set to true. The bit itself is set to false. Bits are indexed starting at 0.\n\nThe default value of T is the PTree hash type (HASH_T).\n\nlowmask(bitno) is equal to ~highmask(bitno).\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.pfill-Union{Tuple{T}, Tuple{T, Vararg{Integer, N} where N}} where T","page":"The Full Air API Reference","title":"Air.pfill","text":"pfill(val, dims...)\n\nYields a persistent array (PArray) of values exactly as done by the fill() function.\n\nSee also pones, pzeros, fill\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> pfill(NaN, 3)\n3-element PArray{Float64,1}:\n NaN\n NaN\n NaN\n\njulia> pfill(:abc, 2, 3)\n2×3 PArray{Symbol,2}:\n :abc  :abc  :abc\n :abc  :abc  :abc\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.pones-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T","page":"The Full Air API Reference","title":"Air.pones","text":"pones(dims...)\npones(T, dims...)\n\nYields a persistent array (PArray) of ones exactly as done by the ones() function.\n\nSee also pzeros, pfill, ones\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> pones(Integer, 3)\n3-element PArray{Integer,1}:\n 1\n 1\n 1\n\njulia> pones(Bool, (1,2))\n1×2 PArray{Bool,2}:\n 1  1\n\njulia> pones(2, 3)\n2×3 PArray{Float64,2}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> pones((1, 1, 1, 1))\n1×1×1×1 PArray{Float64,4}:\n[:, :, 1, 1] =\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.pop","page":"The Full Air API Reference","title":"Air.pop","text":"pop(coll)\n\nYields a tuple (last, most) where last is the last element of the given collection and most is a duplicate tuple of all but the last element of tup. This is basically a persistent equivalent to the pop! function that never modifies the given coll. For persistent collections in Air, these operations are efficient, but for most mutable types, it is O(n).\n\npop(coll, key[, default])\n\nSimilar to pop!, pops the specific key from the given collection coll and yields (val, rest) where val is the value associated with key in coll and rest is the remainder of the collection without key. If the key is not in coll, then default is yielded or an error is thrown.\n\nSee also: Base.pop!, push, popat, delete.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> pop((:a,:b,:c,:d))\n(:d, (:a, :b, :c))\n\njulia> u = [:a,:b,:c,:d]; pop(u)\n(:d, [:a, :b, :c])\n\njulia> length(u)\n4\n\njulia> s = Set([:a, :b, :c]); pop(s, :c)\n(:c, Set([:a, :b]))\n\njulia> :c in s\ntrue\n\njulia> d = Dict(:a => 1, :b => 2, :c => 3); pop(d, :c)\n(3, Dict(:a => 1,:b => 2))\n\njulia> d[:c]\n3\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.popat","page":"The Full Air API Reference","title":"Air.popat","text":"popat(coll, k)\n\nYields a tuple (el, rest) where el is the kth element of the given collection coll and rest is a duplicate of all but the kth element of coll. This is basically a persistent equivalent to the popat! function that never modifies the given coll. For persistent collections in Air, these operations are efficient, but for most mutable types, it is O(n).\n\nSee also: Base.popat!, pop, popfirst, delete.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> popat((:a,:b,:c,:d), 2)\n(:b, (:a, :c, :d))\n\njulia> u = [:a,:b,:c,:d]; popat(u, 3)\n(:c, [:a, :b, :d])\n\njulia> length(u)\n4\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.popfirst","page":"The Full Air API Reference","title":"Air.popfirst","text":"popfirst(coll)\n\nYields a tuple (first, rest) where first is the first element of the given collection and rest is a duplicate tuple of all but the first element of tup. This is basically a persistent equivalent to the popfirst! function that never modifies the given coll. For persistent collections in Air, these operations are efficient, but for most mutable types, it is O(n).\n\nSee also: Base.popfirst!, pushfirst, popat, delete.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> popfirst((:a,:b,:c,:d))\n(:a, (:b, :c, :d))\n\njulia> u = [:a,:b,:c,:d]; popfirst(u)\n(:a, [:b, :c, :d])\n\njulia> length(u)\n4\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.ptree_bitshift-Tuple{UInt64}","page":"The Full Air API Reference","title":"Air.ptree_bitshift","text":"ptree_bitshift(nodeid)\n\nYields the bitshift for the given ptree node id.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_cellindex!-Tuple{UInt64, UInt64, UInt64}","page":"The Full Air API Reference","title":"Air.ptree_cellindex!","text":"ptree_cellindex!(ptree, leafid)\nptree_cellindex!(nodeid, bits, leafid)\n\nYields the index into the ptree's cell vector of the child containing the leaf with the given id. If the ptree does not contain the given leafid because the appropriate bit is not set then 0 is returned. However, unlike the function ptree_cellindex(), this function does not check whether or not the given leafid is in the set of possible children of the tree.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_cellindex-Tuple{UInt64, UInt64, UInt64}","page":"The Full Air API Reference","title":"Air.ptree_cellindex","text":"ptree_cellindex(ptree, leafid)\nptree_cellindex(nodeid, bits, leafid)\n\nYields a tuple (present, bitindex, cellindex) in which [1] present is a boolean indicating whether a ptree containing the given leafid or the leaf itself is a child of the given ptree; [2] bitindex is the index into ptree's bits integer  for the given leaf, and cellindex is the inndex innto the ptree's cell array  where that child is or would be found. If the leafid is outside of the given ptree (i.e., it cannot exist beneath this ptree) then the cellindex returned returned is 0, but the bitindex will still match the appropriate shift for the ptree's depth.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_cellkey-Tuple{UInt64, UInt64}","page":"The Full Air API Reference","title":"Air.ptree_cellkey","text":"ptree_cellkey(ptree, childidx)\n\nYields the leafid (a HASH_T value) of the key that goes with the particular child index that is given. This only works correctly for twig nodes.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_depth-Tuple{UInt64}","page":"The Full Air API Reference","title":"Air.ptree_depth","text":"ptree_depth(nodeaddr)\n\nYields the depth of the node with the given node address. This depth is in the theoretical complete tree, not in the reified tree represented with memory.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_firstbit-Tuple{UInt64}","page":"The Full Air API Reference","title":"Air.ptree_firstbit","text":"ptree_firstbit(nodeid)\n\nYields the first-bit for the given ptree node id.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_highbitdiff-Tuple{UInt64, UInt64}","page":"The Full Air API Reference","title":"Air.ptree_highbitdiff","text":"ptree_highbitdiff(id1, id2)\n\nYields the highest bit that is different between id1 and id2.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_id-Tuple{Integer, Integer}","page":"The Full Air API Reference","title":"Air.ptree_id","text":"ptree_id(minleaf, depth)\n\nYields the node-id for the node whose minimum leaf and depth are given.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_isbeneath-Tuple{UInt64, UInt64}","page":"The Full Air API Reference","title":"Air.ptree_isbeneath","text":"ptree_isbeneath(nodeid, leafid)\n\nYields true if the given leafid can be found beneath the given node-id.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_maxleaf-Tuple{UInt64}","page":"The Full Air API Reference","title":"Air.ptree_maxleaf","text":"ptree_maxleaf(nodeid)\n\nYields the maximum child leaf index assiciated with the given nodeid.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_minleaf-Tuple{UInt64}","page":"The Full Air API Reference","title":"Air.ptree_minleaf","text":"ptree_minleaf(nodeid)\n\nYields the minimum child leaf index associated with the given nodeid.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_minmaxleaf-Tuple{UInt64}","page":"The Full Air API Reference","title":"Air.ptree_minmaxleaf","text":"ptree_minmaxleaf(nodeid)\n\nYields the (min, max) child leaf index assiciated with the given nodeid.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_parentid-Tuple{UInt64}","page":"The Full Air API Reference","title":"Air.ptree_parentid","text":"ptree_parentid(nodeid0)\n\nYields the node-id of the parent of the given node. Note that node 0 (the tree's theoretical root) has no parent. If given a node id of 0, this function will return an arbitrary large number.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.ptree_shift-Tuple{UInt64}","page":"The Full Air API Reference","title":"Air.ptree_shift","text":"ptree_shift(nodeid)\n\nYields the shift for the given ptree node id.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.push","page":"The Full Air API Reference","title":"Air.push","text":"push(coll, val)\npush(coll1, val1, val2...)\n\nYields a copy of the given collection coll with the given value val appended. This function is essentially a persistent equivalent of the push! function that never modifies the object coll. For persistent collections in  the Air library, this operation is efficient, but for most mutable objects, it is O(n).\n\nSee also: Base.push!, pop, Base.setindex!.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> push((:a,:b,:c,:d), :e)\n(:a, :b, :c, :d, :e)\n\njulia> u = [:a,:b,:c,:d]; push(u, :e)\n5-element Array{Symbol,1}:\n :a\n :b\n :c\n :d\n :e\n\njulia> s = Set([:a, :b, :c]); push(s, :d)\nSet{Symbol} with 4 elements:\n  :a\n  :b\n  :d\n  :c\n\njulia> d = Dict(:a => 1, :b => 2); push(d, :c => 3, :d => 4)\nDict{Symbol,Int64} with 4 entries:\n  :a => 1\n  :b => 2\n  :d => 4\n  :c => 3\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.pushfirst","page":"The Full Air API Reference","title":"Air.pushfirst","text":"pushfirst(coll, val)\npushfirst(coll1, val1, val2...)\n\nYields a copy of the given collection coll with the given value val prepended. This function is essentially a persistent equivalent of the pushfirst! function that never modifies the object coll. For persistent collections in the Air library, this operation is efficient, but for most mutable objects, it is O(n).\n\nSee also: Base.pushfirst!, popfirst, Base.setindex!, push.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> pushfirst((:a,:b,:c,:d), :e)\n(:e, :a, :b, :c, :d)\n\njulia> u = [:a,:b,:c,:d]; pushfirst(u, :e)\n5-element Array{Symbol,1}:\n :e\n :a\n :b\n :c\n :d\n\njulia> length(u)\n4\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.pzeros-Union{Tuple{T}, Tuple{Type{T}, Vararg{Integer, N} where N}} where T","page":"The Full Air API Reference","title":"Air.pzeros","text":"pzeros(dims...)\npzeros(T, dims...)\n\nYields a persistent array (PArray) of zeros exactly as done by the zeros() function.\n\nSee also pones, pfill, zeros\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> pzeros(Integer, 3)\n3-element PArray{Integer,1}:\n 0\n 0\n 0\n\njulia> pzeros(Bool, (1,2))\n1×2 PArray{Bool,2}:\n 0  0\n\njulia> pzeros(2, 3)\n2×3 PArray{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> pzeros((1, 1, 1, 1))\n1×1×1×1 PArray{Float64,4}:\n[:, :, 1, 1] =\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}","page":"The Full Air API Reference","title":"Air.reset","text":"reset(actor, x)\n\nIf the given actor is in an error state, this (1) resets it, meaning it will start handling sent messages again, (2) gives it the new initial value x, and (3) yields the ActorException object that was just clared.  If the actor is not in an error state, this just yields nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.send-Union{Tuple{T}, Tuple{Function, Actor{T}}} where T","page":"The Full Air API Reference","title":"Air.send","text":"send(fn, actor)\n\nThe send() method can be used to send a function to an actor. The function fn is put in the actor's queue, which is processed sequentially by a separate thread.  In the actual function call that is evaluated in this separate thread, the function is passed the stored value of the actor, and the return value of the function becomes the new stored value of the actor.\n\nNote that the value of an actor when send() is called does not make any guarantee about its value when the function that is sent gets evaluated–-other functions may be processed in the interim.\n\nIf send() is called inside of a transaction, then the function is not immediately queued but rather is held until the transaction successfully completes. Once this happens, all sends are dispatched simultaneously such that two sends to the same actor during the same transaction will always run back-to-back in the actor's processing thread.\n\nImportant. Due to the design pattern described in the previous paragraph, one should never wait on the result of a function sent to an actor during a transaction. This mistake might be made, for example, by sendng an actor, during a transactoin, a function that delivers some result to a Promise object. If the sending thread then waits on that promise while still in the same transaction then it will deadlock because the sent function is not put in the actor's queue until the enclosing transaction is finished.  Thus the promise will never recieve the result from the actor.\n\nTL;DR–-When you touch an actor in a transaction, it's value freezes inside the transaction. So if the transaction somehow waits for the actor to update or to do something, that transaction will deadlock.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.setfilter!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T","page":"The Full Air API Reference","title":"Air.setfilter!","text":"setfilter!(vol, fn)\n\nSets the filter-function associated with the Volatile object vol. Any time that the vol is set (vol[] = x) the filter-function is called and the value saved in vol is instead fn(x). This must be called within a transaction.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.setfinalize!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T","page":"The Full Air API Reference","title":"Air.setfinalize!","text":"setfinalize!(vol, fn)\n\nSets the finalize-function associated with the Volatile object vol. Any time that a transaction contains a change to vol, immediately prior to making an attempt at committing the transaction, the finalize function is called and the value committed to vol is instead fn(x) where x is the value set to vol in the transaction. This funvtion must also be called within a transaction.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.setvars","page":"The Full Air API Reference","title":"Air.setvars","text":"setvars(f, vardict)\n\nRuns the function f in a context in which all Var objectss have been bound to the values given in the dictionary vardict. The keys of this dictionary must be Var objects. Once the function f has finished running, the Var objects are reverted to their calling-frame values. The current vardict object can be obtained by calling vars().\n\nSee also: Var, @var, vars, withvars, wrapwithvars, wrapsetvars\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> v = Var{Symbol}(:initval)\nVar{Symbol}(@hxC65AWl: :initval; init=:initval)\n\njulia> v[]\n:initval\n\njulia> setvars(IdDict(v => :newval)) do; v[] end\n:newval\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S, X}} where {T, W, F, D, S, X<:Number}","page":"The Full Air API Reference","title":"Air.setweight","text":"setweight(h, x, w)\n\nSets the weight of the value x in the given persistent heap or persistent weighted collection object h to be w and yields the new updated version of h. If x is not already in the object h, then an error is thrown.\n\nSee also: getweight, PWDict, PWSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> d = PWSet{Symbol}(:a => 1.0, :b => 2.0, :c => 3.0)\nPWSet{Symbol,Float64} with 3 elements:\n  :c\n  :b\n  :a\n\njulia> setweight(d, :a, 4.0)\nPWSet{Symbol,Float64} with 3 elements:\n  :a\n  :c\n  :b\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.take-Union{Tuple{Promise{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.take","text":"take(promise)\n\nYields the value delivered to the given Promise object after suspending the current thread to wait for the value if necessary.\n\nSee also Promise, Base.put!.\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> p = Promise()\nPromise{Any}(<...>)\n\njulia> put!(p, :done)\n:done\n\njulia> p\nPromise{Any}(:done)\n\njulia> take(p)\n:done\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.tx-Tuple{F} where F<:Function","page":"The Full Air API Reference","title":"Air.tx","text":"tx(fn)\n\nRuns the given function in a transaction and yields the result. The function fn is called as fn() without arguments.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.tx_actordata-Union{Tuple{Actor{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.tx_actordata","text":"tx_actordata(a)\n\nYields the in-transaction data for the Actor object a. If a is in an error-state, then throws an ActorException. If there is no transaction currently running, yields nothing.\n\nThis function is considered part of the internal/private interface of Air and shouldn't generally be called outside of it.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.vars","page":"The Full Air API Reference","title":"Air.vars","text":"vars()\n\nYields an IdDict{Var,Any} object that contains a mapping of all Var objects whose current in-task value is not its default value to that Var's currently assigned value. The dictionary returned by vars may be later restored using the function setvars.\n\nSee also: setvars, withvars, wrapwithvars, Var.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> vars()\nIdDict{Var,Any}()\n\njulia> @var v = :test::Symbol\nVar{Symbol}(@h4G6oRR9s: :test; init=:test)\n\njulia> withvars(v => :temp) do; vars() end\nIdDict{Var,Any} with 1 entry:\n  Var{Symbol}(@AaE16J5Pic8) => :temp\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.voldata_finalize-Union{Tuple{Air.VolatileData{T}}, Tuple{T}} where T","page":"The Full Air API Reference","title":"Air.voldata_finalize","text":"voldata_finalize(voldata)\n\nCalls the finalize function of the given volatile state object (of type VolatileData) if necessary. Yields the new VolatileData object, which may be voldata if there is no finalizer or nothing has changed.\n\nThis function is a private/internal implementation detail of the Air library.\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.withvars","page":"The Full Air API Reference","title":"Air.withvars","text":"withvars(f, var1 => val1, var2 => val2...)\nwithvars(f, vardict)\n\nRuns the function f in a context in which the given Vars have been bound to the given values. In the vase of a dictionary passed as the second argument, the keys must be Var objects. Once the function f has finished running, the Var objects are reverted to their calling-frame values.\n\nSee also: Var, @var, vars, setvars, wrapwithvars, wrapsetvars\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> v = Var{Symbol}(:initval)\nVar{Symbol}(@cFgU9Kqe8: :initval; init=:initval)\n\njulia> v[]\n:initval\n\njulia> withvars(v => :newval) do; v[] end\n:newval\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.wrapsetvars","page":"The Full Air API Reference","title":"Air.wrapsetvars","text":"wrapsetvars(f, vardict)\n\nEquivalent to setvars(f, args...) except that instead of running f  immediately in the context of the modified Vars, yields a wrapper around f that, when called, passes all arguments to f, which is run using the given variable bindings in the dictionary vardict.\n\nSee also: Var, @var, vars, withvars, setvars, wrapwithvars\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> v = Var{Int}(0)\nVar{Int64}(@F6ku5d8: 0; init=0)\n\njulia> v[]\n0\n\njulia> vs = withvars(v => 2) do; vars() end; length(vs)\n1\n\njulia> f = wrapsetvars(vs) do x; x + v[] end; f(10)\n12\n\n\n\n\n\n","category":"function"},{"location":"API/#Air.wrapwithvars","page":"The Full Air API Reference","title":"Air.wrapwithvars","text":"wrapwithvars(f, var1 => val1, var2 => val2...)\nwrapwithvars(f, vardict)\n\nEquivalent to withvars(f, args...) except that instead of running f  immediately in the context of the modified Vars, yields a wrapper around f that, when called, passes all arguments to f, which is run using the current variable bindings plus any given bindings. Notable, wrapwithvars(f) will create a wrapped version of f that uses the Var bindings in the current task.\n\nSee also: Var, @var, vars, withvars, setvars, wrapsetvars\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> v = Var{Int}(0)\nVar{Int64}(@JIm7aUS2sOl: 0; init=0)\n\njulia> v[]\n0\n\njulia> f = wrapwithvars(v => 2) do x; x + v[] end; f(10)\n12\n\n\n\n\n\n","category":"function"},{"location":"API/#Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, S, Vararg{Any, N} where N}} where {T, N, S}","page":"The Full Air API Reference","title":"Base.setindex","text":"setindex(coll, val, index)\n\nYields a copy of the given collection coll with the value val set at the given index. This is a persistent version of setindex! and works for most collection types including Arrays, Dicts, IdDicts, and Air's persistent versions of these.\n\nNote that setindex() always returns a copy of the argument coll or fails. For Air's persistent collections these operations are efficient, but for the mutable counterparts, they are typically O(n).\n\nSee also: Base.setindex!, push.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> setindex((:a,:b,:e,:d), :c, 3)\n(:a, :b, :c, :d)\n\njulia> u = [:a,:b,:e,:d]; v = setindex(u, :c, 3)\n4-element Array{Symbol,1}:\n :a\n :b\n :c\n :d\n\njulia> u == v\nfalse\n\njulia> u[3]\n:e\n\njulia> d1 = Dict(); setindex(d1, 10, :a)\nDict{Any,Any} with 1 entry:\n  :a => 10\n\njulia> d1\nDict{Any,Any}()\n\n\n\n\n\n","category":"method"},{"location":"API/#SparseArrays.dropzeros-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"The Full Air API Reference","title":"SparseArrays.dropzeros","text":"dropzeros(p::PArray)\n\nDrops explicit values of the given array p that are equal to the array's default value. This differs from the SparseArrays implementation of dropzeros() only in that PArrays allow arbitrary default values, while SparseArrays allow only the default value of zero.\n\nNote that under most circumstances, a PArrray will not encode explicit zeros, so this function typically returns the object p untouched.\n\nSee also: SparseArrays.nnz, SparseArrays.findnz, PArray.\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> u = PVector{Int}([0,1,2,3])\n4-element PArray{Int64,1}:\n 0\n 1\n 2\n 3\n\njulia> dropzeros(u) === u\ntrue\n\njulia> v = setindex(u, 0, 3)\n4-element PArray{Int64,1}:\n 0\n 1\n 0\n 3\n\njulia> dropzeros(v) === v\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#SparseArrays.findnz-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"The Full Air API Reference","title":"SparseArrays.findnz","text":"findnz(p::PArray)\n\nYields the explicitly set elements of the given persistent array p. This method is identical to the typical SparseArrays implementation of findnz() except that it respects the arbitrary default-value that persistent arrays are allowed to have rather than assuming that this value is a zero, as is done in the SparseArrays library.\n\nNote that under most circumstances, a PArray will not encode explicit zeros, so this function typically returns indices and values for all values that aren't equal to the default value of the array p (which is zero by default).\n\nSee also: SparseArrays.nnz, PArray.\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> u = PVector([0,10,20,30])\n4-element PArray{Int64,1}:\n  0\n 10\n 20\n 30\n\njulia> findnz(u)\n([1, 2, 3, 4], [0, 10, 20, 30])\n\njulia> u = setindex(PVector(0.0, 4), 20, 2)\n4-element PArray{Float64,1}:\n  0.0\n 20.0\n  0.0\n  0.0\n\njulia> findnz(u)\n([2], [20.0])\n\n\n\n\n\n","category":"method"},{"location":"API/#SparseArrays.nnz-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"The Full Air API Reference","title":"SparseArrays.nnz","text":"nnz(p::PArray)\n\nYields the number of explicitly set values in the persistent array p, regardless of the number that are zero. This is different from the sparse-array library only in that persistent arrays support arbitrary default values instead of supporting only the value zero. Thus this counts explicit values instead of non-zero values.\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> u = PVector{Int}(0, (4,))\n4-element PArray{Int64,1}:\n 0\n 0\n 0\n 0\n\njulia> v = setindex(u, 2, 3)\n4-element PArray{Int64,1}:\n 0\n 0\n 2\n 0\n\njulia> nnz(v)\n1\n\njulia> nnz(u)\n0\n\n\n\n\n\n","category":"method"},{"location":"API/#SparseArrays.nonzeros-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"The Full Air API Reference","title":"SparseArrays.nonzeros","text":"nonzeros(p::PArray)\n\nYields the explicitly set values of the given persistent array p. This method is identical to the typical SparseArrays implementation of nonzeros() for  its sparse array classes except that it returns a persistent array of values and that it respects the arbitrary default-value that persistent arrays are allowed to have rather than assuming that this value is a zero, as is done in the SparseArrays library.\n\nNote that because PArrays don't typically store values equal to their default value explicitly, this will typically yield a vector of every non-default value in the array.\n\nSee also: SparseArrays.findnz, SparseArrays.nnz, PArray.\n\nExamples\n\nDocTestSetup = quote\n    using Air, SparseArrays\nend\n\njulia> u = PVector([0,10,20,30])\n4-element PArray{Int64,1}:\n  0\n 10\n 20\n 30\n\njulia> nonzeros(u)\n4-element PArray{Int64,1}:\n  0\n 10\n 20\n 30\n\njulia> u = setindex(PVector(0.0, 4), 20, 2)\n4-element PArray{Float64,1}:\n  0.0\n 20.0\n  0.0\n  0.0\n\njulia> nonzeros(u)\n1-element PArray{Float64,1}:\n 20.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Air.@delay-Tuple{Expr}","page":"The Full Air API Reference","title":"Air.@delay","text":"@delay expression\n\nYields a Delay object that matches the given expression. The expression may be one of the following:\n\nA function of no arguments, such as () -> 10; in this case the delay is made from this function (i.e., the RHS is the -> expression that is delayed).\nA function with a set of symbol arguments evaluates the RHS but uses a let statement to wrap all the symbols in the LHS into a closure.\nAn expression, which is treated as equivalent to () -> expression.\n\nOptionally, the expression or LHS may be tagged with a type T. In this case, a Delay{T} object is yielded instead of a Delay{Any}.\n\nSee also: Delay, LazyDict\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> # Create a Delay with a long run time.\n       d = (@delay (println(\"Running.\"); sleep(2); 10)::Int64)\nDelay{Int64}(<...>)\n\njulia> # Start a few threads, each of which attempt to read it. The function will\n       # only run once.\n       for th in [(Threads.@spawn d[]) for _ in 1:5]; wait(th) end\nRunning.\n\njulia> # Ensure that it produced the correct value and doesn't run again.\n       d[]\n10\n\njulia> # The display now shows the realized value also.\n       d\nDelay{Int64}(10)\n\njulia> # Create a Delay with a locally-bound symbol.\n       d2 = (@delay (d) -> (d[] / 20.0)::Float64)\nDelay{Float64}(<...>)\n\njulia> # We can rebind d without affecting d2.\n       d = 10\n10\n\njulia> d2[]\n0.5\n\n\n\n\n\n","category":"macro"},{"location":"API/#Air.@memoize-Tuple{Expr}","page":"The Full Air API Reference","title":"Air.@memoize","text":"@memoize name(args...) = expr\n@memoize name(args...) where {...} = expr\n\n@memoize is a macro for declaring that the function declaration that follows should be memoized in a private dictionary and any pre-calculated value should be returned from that dictionary instead of being recalculated. All memoization is thread-safe: expr is only ever evaluated by one thread at a time, and is only ever evaluated once per unique set of arguments.\n\nNote that arguments are memoized according to equality, so the use of mutable arguments can result in undefined behavior of those arguments are later changed.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> @memoize fib(n::Int) = begin\n           println(\"Calculating fib($n)...\")\n           if n < 1\n               return 0\n           elseif n == 1\n               return 1\n           else\n               return fib(n-1) + fib(n - 2)\n           end\n       end::Int\nfib (generic function with 1 method)\n\njulia> fib(5)\nCalculating fib(5)...\nCalculating fib(4)...\nCalculating fib(3)...\nCalculating fib(2)...\nCalculating fib(1)...\nCalculating fib(0)...\n5\n\njulia> fib(6)\nCalculating fib(6)...\n8\n\n\n\n\n\n","category":"macro"},{"location":"API/#Air.@p-Tuple","page":"The Full Air API Reference","title":"Air.@p","text":"@p{k1 => v1, k2 => v2, ...}\n@p[x1, x2, ...]\n@p[x1 x2...]\n@p(x1, x2, ...)\n\nYields a persistent data structure, depending on how the macro is called. This is a shorthand for calling the various constructors directly. The following expressions are equivalent:\n\n@p{k1 => v1, k2 => v2, ...} and PDict(k1 => v1, k2 => v2, ...)\n@p[x1, x2, ...] and PVector([x1, x2, ...])\n@p[x1 x2 ...] and PArray([x1 x2 ...])\n@p(x1, x2, ...) and PSet([x1, x2, ...]\n\nSee also: PDict, PVector, PArray, PSet.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> @p{:a => 1, :b => 2, :c => 3}\nPDict{Symbol,Int64} with 3 entries:\n  :c => 3\n  :a => 1\n  :b => 2\n\njulia> @p[1, 2, 3, 4]\n4-element PArray{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> @p[:q2 :q1; :q3 :q4]\n2×2 PArray{Symbol,2}:\n :q2  :q1\n :q3  :q4\n\njulia> @p(:a, :b, :a, :c)\nPSet{Symbol} with 3 elements:\n  :c\n  :a\n  :b\n\n\n\n\n\n","category":"macro"},{"location":"API/#Air.@tx-Tuple{Any}","page":"The Full Air API Reference","title":"Air.@tx","text":"@tx expr\n\nThe macro @tx should be followed by an expression; that expression is run in an atomic transaction.\n\n\n\n\n\n","category":"macro"},{"location":"API/#Air.@var-Tuple{Expr}","page":"The Full Air API Reference","title":"Air.@var","text":"@var\n\nConvenient syntax for creating a task-local Var object: @var name = initval will construct a Var object with the given initial value. @var name = initval::T will create a Var{T} object.\n\nSee also: Var.\n\nExamples\n\nDocTestSetup = quote\n    using Air\nend\n\njulia> @var v = :start_sym\nVar{Symbol}(@JIm7aUS2sOl: :start_sym; init=:start_sym)\n\njulia> @var u = :start_sym::Any\nVar{Any}(@JIm7aUS2sOl: :start_sym; init=:start_sym)\n\n\n\n\n\n","category":"macro"}]
}
